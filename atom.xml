<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Riroaki&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T17:11:49.263Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Riroaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ML-3.Classification：以少女前线为例讲解朴素贝叶斯分类算法</title>
    <link href="http://yoursite.com/2019/04/07/ML-4-Classification/"/>
    <id>http://yoursite.com/2019/04/07/ML-4-Classification/</id>
    <published>2019-04-07T08:29:08.000Z</published>
    <updated>2019-04-08T17:11:49.263Z</updated>
    
    <content type="html"><![CDATA[<p>看了李宏毅老师的视频，决定以少女前线的枪种分类为例，试做一个朴素贝叶斯分类器。</p><p><img src="/2019/04/07/ML-4-Classification/head.jpg" alt></p><p><s>找配图的时间比码字时间还长</s>我永远喜欢忤逆小队！</p><a id="more"></a><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="话题引入"><a href="#话题引入" class="headerlink" title="话题引入"></a>话题引入</h3><p>首先做一个题。</p><p>我有两个抽屉A和B，里面放着白球和红球；</p><p>A中红球和白球的个数比为1:3，B中红球和白球的个数比为2:3；</p><p>现在要从两个抽屉中抽一个球，从A抽屉和B抽屉中选择的概率比为1:2；</p><p>如果抽中红球，问：求抽到的球来自A抽屉的概率？</p><p>答案很简单，$P(A | red) = \frac{P(A) <em> P(red | A)}{P(A) </em> P(red | A) + P(b) * P(red | B)}$</p><h3 id="分类思想"><a href="#分类思想" class="headerlink" title="分类思想"></a>分类思想</h3><p>现在我们不妨脑洞大开一下，把一个抽屉当作一个类别，把球当做一个需要分类的对象，我们需要找到这个球是哪一类的，其实就是找到这个球来自哪个抽屉，这样就和上面的公式是一回事了。</p><p>换言之，对某一个待归类的x，我们把它当作是已经取出的”球”，通过计算某个类别（抽屉）产生出case（从这一抽屉中抽球）的概率，以及各个类别（抽屉）产生出这一个x的概率，就可以计算出x属于每一类的概率。</p><p>当它属于某一类A的概率最大的时候，我们就将它分类为A类。</p><p>这一模型又被称为generative model——生成模型，也就是说这个模型其实不单可以归类，也可以用于产生case。</p><h3 id="具体分析产生的模型是什么样的？"><a href="#具体分析产生的模型是什么样的？" class="headerlink" title="具体分析产生的模型是什么样的？"></a>具体分析产生的模型是什么样的？</h3><p>根据刚才的模型，我们需要两个参数才能计算分类概率：</p><ol><li>某个类生产case的概率（从这个抽屉抽球的概率）</li><li>这个类产生出的case是x的概率（抽到的球是红球的概率）</li></ol><p>对1，使用训练集中该类的数据量占总数据量的个数作为这个类生产case的概率。</p><p>比较复杂的是2：<strong>生成的数据是x的概率如何计算</strong>？</p><p>我们以少前各个枪种为例：每一把枪具有血量、伤害、命中、回避、射速等等数值属性，它们都是一定范围内的整数，可以看作连续变量，而且同一类枪种的某一属性值都比较接近（比如，rf狙击枪的满级伤害普遍在120+，而射速普遍在40以下），可以认为是一个多维的正态分布生成的。</p><p>这样一来，我们可以以x属性在这一正态分布下的概率密度（注意，离散变量谈概率而连续变量谈概率密度）作为生成数据是x的概率。</p><p>那么，<strong>怎样求出这一个正态分布的参数</strong>？</p><p>方法是极大似然估计：选取让过去发生的事情可能性最大的参数。</p><p>对一个正态分布$f_{\mu,\sum}$，它得出之前的case的概率越大，它就越好。</p><p>所以把最大似然作为目标函数，取微分为0的参数为最好的参数（过程略）：</p><ul><li><p>对一类train data，取它们的平均值作为$\mu$即$\mu=\frac{\sum_{i=1}^nx^i}{n}$，而$\sum=\frac{\sum^n_{i=1}(x^i-\mu)(x^i-\mu)^T}{n}$。</p></li><li><p>注意这里的$\mu$是维度等于属性个数的向量，$\sum$是一个维度等于属性个数的方阵。</p></li></ul><p>有了参数，<strong>如何评估产生x的可能性</strong>？</p><p>套公式呗。高斯分布的概率密度公式如下图：</p><p><img src="/2019/04/07/ML-4-Classification/gaussian.PNG" alt></p><blockquote><p>多元正态分布的参数：</p><p>先从各维度不相关的多元正态分布入手，数据点通过d维的列向量描述$x=\left[ x_1,x_2,\cdots,x_d \right]^T​$，各个维度的均值方差分别为$[\mu_1,\mu_2,\cdots,\mu_d]​$ , $[\sigma_1,\sigma_2,\cdots,\sigma_d]​$ 来描述，高斯概率密度函数可以表示为：</p><p>$f(x)=\frac{1}{(\sqrt{2\pi})^d\sigma_1\sigma_2\cdots\sigma_d}e^{-\frac{1}{2}[(\frac{x_1-\mu_1}{\sigma_1})^2+(\frac{x_2-\mu_2}{\sigma_2})^2+\cdots+(\frac{x_d-\mu_1}{\sigma_d})^2]}​$</p><p>前面多出的项是为了让概率之和为1，其实这个方程可以这样子去解读：</p><p>$f(x)=\frac{1}{(\sqrt{2\pi})\sigma_1}e^{-\frac{1}{2}(\frac{x_1-\mu_1}{\sigma_1})^2}\frac{1}{(\sqrt{2\pi})\sigma_2}e^{-\frac{1}{2}(\frac{x_2-\mu_2}{\sigma_2})^2}\cdots\frac{1}{(\sqrt{2\pi})\sigma_d}e^{-\frac{1}{2}(\frac{x_d-\mu_d}{\sigma_d})^2}$</p><p>当我们考虑变量之间的并不独立的情况，我们可以用$\sum​$相关矩阵取代$\sigma​$向量（其实原本的$\sigma​$向量可以看作代表一个主对角阵）</p></blockquote><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>多说无益，开始写代码。</p><p>==前方代码高乱预警，强迫症退散==</p><ul><li>首先，输入数据并切分成train和test：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">(file)</span>:</span></span><br><span class="line">    content = np.loadtxt(file, dtype=np.str, delimiter=<span class="string">','</span>)[<span class="number">1</span>:]</span><br><span class="line">    types = [line[<span class="number">2</span>] <span class="keyword">for</span> line <span class="keyword">in</span> content]</span><br><span class="line">    attrs = [[float(num) <span class="keyword">for</span> num <span class="keyword">in</span> line[<span class="number">6</span>:<span class="number">11</span>]] <span class="keyword">for</span> line <span class="keyword">in</span> content]</span><br><span class="line">    <span class="keyword">return</span> types, attrs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitCases</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(x) != len(y):</span><br><span class="line">        <span class="keyword">return</span> [], [], [], []</span><br><span class="line">    trainX, trainY, testX, testY = [], [], [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> randint(<span class="number">1</span>, <span class="number">4</span>) &gt; <span class="number">3</span>:</span><br><span class="line">            testX.append(x[i])</span><br><span class="line">            testY.append(y[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            trainX.append(x[i])</span><br><span class="line">            trainY.append(y[i])</span><br><span class="line">    <span class="keyword">return</span> trainX, trainY, testX, testY</span><br><span class="line"></span><br><span class="line">types, attrs = loadData(<span class="string">'./data/gf.csv'</span>)</span><br><span class="line">TrainX, TrainY, TestX, TestY = splitCases(attrs, types)</span><br></pre></td></tr></table></figure><ul><li>接下来按照枪种分类形成字典，并且计算出每一类枪的高斯分布参数：<ul><li>这里代码开始乱了……我也不知道自己在些什么，过程参数和变量满天飞</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitByType</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    _groups = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> y[_i] <span class="keyword">not</span> <span class="keyword">in</span> _groups:</span><br><span class="line">            _groups[y[_i]] = []</span><br><span class="line">        _groups[y[_i]].append(x[_i])</span><br><span class="line">    <span class="keyword">return</span> _groups</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussianFit</span><span class="params">(_attr)</span>:</span></span><br><span class="line">    _n, _m = len(_attr), len(_attr[<span class="number">0</span>])</span><br><span class="line">    _mean = np.zeros(_m)</span><br><span class="line">    _sigma = np.mat(np.zeros((_m, _m)))</span><br><span class="line">    <span class="keyword">for</span> _j <span class="keyword">in</span> range(_m):</span><br><span class="line">        <span class="keyword">for</span> _i <span class="keyword">in</span> range(_n):</span><br><span class="line">            _mean[_j] += _attr[_i][_j]</span><br><span class="line">        _mean[_j] /= _n</span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> range(_n):</span><br><span class="line">        _tmp = np.mat([_attr[_i][_j] - _mean[_j] <span class="keyword">for</span> _j <span class="keyword">in</span> range(_m)])</span><br><span class="line">        _sigma += np.transpose(_tmp) * _tmp</span><br><span class="line">    <span class="keyword">return</span> _mean, _sigma</span><br><span class="line"></span><br><span class="line">Group = splitByType(TrainX, TrainY)</span><br><span class="line">names, pClass, means, sigmas = [], [], [], []</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> name, attr <span class="keyword">in</span> Group.items():</span><br><span class="line">    names.append(name)</span><br><span class="line">    pClass.append(len(attr))</span><br><span class="line">    count += len(attr)</span><br><span class="line">    mean, sigma = gaussianFit(attr)</span><br><span class="line">    means.append(mean)</span><br><span class="line">    sigmas.append(sigma)</span><br><span class="line">pClass = [num / count <span class="keyword">for</span> num <span class="keyword">in</span> pClass]</span><br></pre></td></tr></table></figure><ul><li>（<strong>主体</strong>）计算每种枪的概率，找到概率最大作为分类：<ul><li>这里的计算其实我也晕乎乎的。。就套公式吧。。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcPossibility</span><span class="params">(x, i: int)</span>:</span></span><br><span class="line">    _tmp = np.mat(x - means[i])</span><br><span class="line">    _inv = np.linalg.inv(sigmas[i])</span><br><span class="line">    _exp = np.exp(<span class="number">-0.5</span> * _tmp * _inv * np.transpose(_tmp))</span><br><span class="line">    <span class="keyword">return</span> pClass[i] * _exp / np.sqrt(np.linalg.det(sigmas[i]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifier</span><span class="params">(x)</span>:</span></span><br><span class="line">    _maxId, _maxP = <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> range(len(names)):</span><br><span class="line">        _currP = calcPossibility(x, _i)</span><br><span class="line">        <span class="keyword">if</span> _maxP &lt; _currP :</span><br><span class="line">            _maxId, _maxP = _i, _currP</span><br><span class="line">    <span class="keyword">return</span> names[_maxId]</span><br></pre></td></tr></table></figure><ul><li>测试数据：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(TestX)):</span><br><span class="line">    guess = classifier(TestX[i])</span><br><span class="line">    print(<span class="string">'predict: %s, answer: %s'</span> % (guess, TestY[i]))</span><br><span class="line">    <span class="keyword">if</span> guess == TestY[i]:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">print(<span class="string">'Rate of correct predictions: %f'</span> % (correct / len(TestX)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: SG, answer: SG</span><br><span class="line">predict: SG, answer: SG</span><br><span class="line">predict: SG, answer: SG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: MG, answer: MG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: SG, answer: SG</span><br><span class="line">predict: AR, answer: AR</span><br><span class="line">predict: SG, answer: SG</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">Rate of correct predictions: 1.000000</span><br></pre></td></tr></table></figure><p>竟然是100%！这么高的准确率，我佛了。。</p><p>大概是因为少前里面每一种枪的特征太好区分了吧。</p><p>这里用sklearn的库再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">model = GaussianNB()</span><br><span class="line">model.fit(TrainX, TrainY)</span><br><span class="line">res = model.predict(TestX)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">    print(<span class="string">'predict: %s, answer: %s'</span> % (res[i], TestY[i]))</span><br><span class="line">    <span class="keyword">if</span> res[i] == TestY[i]:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">print(<span class="string">'Rate of correct predictions: %f'</span> % (count / len(TestY)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: HG, answer: HG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: SMG, answer: SMG</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">predict: RF, answer: RF</span><br><span class="line">...</span><br><span class="line">Rate of correct predictions: 1.000000</span><br></pre></td></tr></table></figure><ul><li>毫无悬念的100%……好吧这说明少前的数据确实特征很明显=。=</li></ul><hr><h3 id="可不可以用回归的方法直接做分类？"><a href="#可不可以用回归的方法直接做分类？" class="headerlink" title="可不可以用回归的方法直接做分类？"></a>可不可以用回归的方法直接做分类？</h3><p>一般这么做不好。</p><p>举个例子，用一个回归函数的值和分类对应，函数值接近1就是A类，接近2就是B类，以此类推。</p><p>这样固然可以训练出拟合train data的模型，但是数值上的接近关系不一定就能反映出分类之间的关系（比如，1和2比起1和3更接近，但是A和B不一定就能够比A和C的关系更接近），这样的拟合是不符合分类规律的。</p><h3 id="贝叶斯算法一定是用高斯（正太）分布嘛？"><a href="#贝叶斯算法一定是用高斯（正太）分布嘛？" class="headerlink" title="贝叶斯算法一定是用高斯（正太）分布嘛？"></a>贝叶斯算法一定是用高斯（正太）分布嘛？</h3><p>不一定。这里是根据变量的分布特征决定的，其他还有如多项式模型和伯努利模型都是常见的分布模型。</p><p>特征是离散的时候，一般使用多项式模型；</p><p>特征是离散而且只有0和1两种分布的时候，一般采用伯努利模型。</p><p>特征是连续的时候，一般使用高斯分布模型；</p><h3 id="其他分类器有哪些？"><a href="#其他分类器有哪些？" class="headerlink" title="其他分类器有哪些？"></a>其他分类器有哪些？</h3><p>逻辑回归，SVM，和决策树等等。</p><p>逻辑回归适合线性数据，处理不好特征存在相关的情况。</p><p>SVM非常耗时间，工业上不推荐。</p><p>决策树适合用在特征是离散型的变量上。</p><p>贝叶斯通常是用在NLP里面用来做文本分类等等的事情（用在这里也只是因为李宏毅老师讲了这个）</p><p>我还暂时说不清楚他们的具体优劣，可以参考<a href="https://blog.csdn.net/July_sun/article/details/53088673" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了李宏毅老师的视频，决定以少女前线的枪种分类为例，试做一个朴素贝叶斯分类器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/07/ML-4-Classification/head.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;找配图的时间比码字时间还长&lt;/s&gt;我永远喜欢忤逆小队！&lt;/p&gt;
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="naive bayesian" scheme="http://yoursite.com/tags/naive-bayesian/"/>
    
  </entry>
  
  <entry>
    <title>32.Longest Valid Partheses</title>
    <link href="http://yoursite.com/2019/04/07/32-Longest-Valid-Partheses/"/>
    <id>http://yoursite.com/2019/04/07/32-Longest-Valid-Partheses/</id>
    <published>2019-04-06T18:23:15.000Z</published>
    <updated>2019-04-08T17:12:56.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"(()"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">"()"</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">")()())"</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">"()()"</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="暴力求解全部序列找最长"><a href="#暴力求解全部序列找最长" class="headerlink" title="暴力求解全部序列找最长"></a>暴力求解全部序列找最长</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">      <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &lt; n; end++) &#123;</span><br><span class="line">          balance = s.charAt(end) == <span class="string">'('</span> ? <span class="number">1</span> :  -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (balance == <span class="number">0</span>)</span><br><span class="line">              res = Math.max(res, end - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 待补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; and &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;, find the length of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>31.Next Permutation</title>
    <link href="http://yoursite.com/2019/04/07/31-Next-Permutation/"/>
    <id>http://yoursite.com/2019/04/07/31-Next-Permutation/</id>
    <published>2019-04-06T18:08:17.000Z</published>
    <updated>2019-04-06T18:25:36.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be <strong>in-place</strong> and use only constant extra memory.</p><a id="more"></a><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="暴力求解全排列"><a href="#暴力求解全排列" class="headerlink" title="暴力求解全排列"></a>暴力求解全排列</h4><ul><li><p>时间复杂度：$O(n!)$</p></li><li><p>空间复杂度：$O(n)$</p></li></ul><h4 id="寻找排列规律"><a href="#寻找排列规律" class="headerlink" title="寻找排列规律"></a>寻找排列规律</h4><ul><li>找到前一个排列和后一个排列的关系<ul><li>例如，<code>1234</code>—&gt;<code>1243</code></li><li><code>3124</code>—&gt;<code>3214</code></li><li><code>4321</code>—&gt;<code>1234</code></li><li>从右到左，找到第一个违反【非降序规律】的数，将它和右边第一个比它大的数交换（交换其实是让它插入合适的位置）（这里可以用二分查找），然后逆序排列（也就是让剩下来的数按照从左到右非降序排列）</li></ul></li><li>注意⚠️，可能出现重复数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from, j = to - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">          swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, iter, last = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (last &gt;= <span class="number">0</span> &amp;&amp; nums[last] &gt;= nums[last + <span class="number">1</span>])</span><br><span class="line">            last--;</span><br><span class="line">        <span class="keyword">if</span> (last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minBigger = last + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (minBigger &lt; n - <span class="number">1</span> </span><br><span class="line">                   &amp;&amp; nums[minBigger + <span class="number">1</span>] &gt; nums[last])</span><br><span class="line">                minBigger++;</span><br><span class="line">            swap(nums, last, minBigger);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, last + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Implement &lt;strong&gt;next permutation&lt;/strong&gt;, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;
&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;
&lt;p&gt;The replacement must be &lt;strong&gt;in-place&lt;/strong&gt; and use only constant extra memory.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
      <category term="permutation" scheme="http://yoursite.com/tags/permutation/"/>
    
  </entry>
  
  <entry>
    <title>Code Jam 2019 Qualification Round</title>
    <link href="http://yoursite.com/2019/04/07/Code-Jam-2019-Qualification-Round/"/>
    <id>http://yoursite.com/2019/04/07/Code-Jam-2019-Qualification-Round/</id>
    <published>2019-04-06T17:48:25.000Z</published>
    <updated>2019-04-08T17:12:16.929Z</updated>
    
    <content type="html"><![CDATA[<p>准备打一下今年的code jam和kick start，看了一下code jam是采取连续比赛的机制，kick start是每一轮独立。</p><p>今天写一下关于code jam的资格赛的事情。</p><p>QR在4月5日早上七点开始，持续27小时，只要在难度不大的四题（总分100）里面做出30分就可以。</p><p>贴一下战绩：55分，其实挺低的……还需要加油</p><a id="more"></a><h3 id="Foregone-Solution"><a href="#Foregone-Solution" class="headerlink" title="Foregone Solution"></a>Foregone Solution</h3><blockquote><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Someone just won the Code Jam lottery, and we owe them <strong>N</strong> jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of <strong>N</strong>, which is an integer, includes at least one digit that is a <code>4</code>… and the <code>4</code>key on the keyboard of our oversized check printer is broken.</p><p>Fortunately, we have a workaround: we will send our winner two checks for positive integer amounts A and B, such that neither A nor B contains any digit that is a <code>4</code>, and A + B = <strong>N</strong>. Please help us find any pair of values A and B that satisfy these conditions.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> test cases follow; each consists of one line with an integer <strong>N</strong>.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: A B</code>, where <code>x</code> is the test case number (starting from 1), and <code>A</code> and <code>B</code> are positive integers as described above.</p><p>It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them. (See “What if a test case has multiple correct solutions?” in the Competing section of the <a href="https://codingcompetitions.withgoogle.com/codejam/faq" target="_blank" rel="noopener">FAQ</a>. This information about multiple solutions will not be explicitly stated in the remainder of the 2019 contest.)</p><h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.<br>Time limit: 10 seconds per test set.<br>Memory limit: 1GB.<br>At least one of the digits of <strong>N</strong> is a 4.</p><h4 id="Test-set-1-Visible"><a href="#Test-set-1-Visible" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h4><p>1 &lt; <strong>N</strong> &lt; 105.</p><h4 id="Test-set-2-Visible"><a href="#Test-set-2-Visible" class="headerlink" title="Test set 2 (Visible)"></a>Test set 2 (Visible)</h4><p>1 &lt; <strong>N</strong> &lt; 109.</p><p>Solving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights!</p><h4 id="Test-set-3-Hidden"><a href="#Test-set-3-Hidden" class="headerlink" title="Test set 3 (Hidden)"></a>Test set 3 (Hidden)</h4><p>1 &lt; <strong>N</strong> &lt; 10100.</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td><code>3 4 940 4444</code></td><td><code>Case #1: 2 2 Case #2: 852 88 Case #3: 667 3777</code></td></tr></tbody></table><p>In Sample Case #1, notice that A and B can be the same. The only other possible answers are <code>1 3</code> and <code>3 1</code>.</p></blockquote><p>这题是米斯达保护协会出的（迫真）</p><p>其实就是把一个包含<code>4</code>的数拆分成两个不同的数，但是这两个数不能包含<code>4</code>。</p><p>只要有一个固定的拆分方法就可以：</p><ul><li>对每一个位上的数字<code>a</code>，如果不是<code>4</code>，就拆分成<code>a</code>和<code>0</code>；</li><li>否则拆出两个<code>2</code></li></ul><p>时间复杂度：$O(log(n))$</p><p>空间复杂度：$O(1)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            BigInteger sum = in.nextBigInteger(), num = splitWithout4(sum);</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + i + <span class="string">": "</span> + num + <span class="string">" "</span> + sum.subtract(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigInteger <span class="title">splitWithout4</span><span class="params">(BigInteger sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = sum.toString().toCharArray();</span><br><span class="line">        BigInteger res = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">        BigInteger three = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>),</span><br><span class="line">            two = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>),</span><br><span class="line">            ten = <span class="keyword">new</span> BigInteger(<span class="string">"10"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ch) &#123;</span><br><span class="line">            res = res.multiply(ten);</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'4'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'6'</span>)</span><br><span class="line">                    res = res.add(three);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = res.add(two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛结束一看，竟然没过hidden case……</p><p>想了一会恍然大悟：位数不够！</p><p>那就该用<code>BigInteger</code>库了。</p><hr><p>这里插播一下<code>java.math.BigInteger</code>库，好像是1.7版本的jdk开始支持的。</p><p>因为java最大的整数使用<code>long</code>存的，数位最大不过64bit，也就是说最大表示不到2的63次方，最小自然是负的2的63次方。这样计算起来不过就是1e20左右嘛，根本不够看的。</p><p>所以java使用大整数库来操作比较长的数，方法是将数存在<code>String</code>里面，然后对加减乘除模，位运算等等都单独内置了支持（还支持了gcd，好评！）</p><p>因为是使用字符串表示，字符串长度是一个<code>int</code>值，最长就是<code>Integer.MAX_VALUE</code>，一般够用了</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            BigInteger sum = in.nextBigInteger(), num = splitWithout4(sum);</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + i + <span class="string">": "</span> + num + <span class="string">" "</span> + sum.subtract(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigInteger <span class="title">splitWithout4</span><span class="params">(BigInteger sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = sum.toString().toCharArray();</span><br><span class="line">        BigInteger res = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">        BigInteger three = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>),</span><br><span class="line">            two = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>),</span><br><span class="line">            ten = <span class="keyword">new</span> BigInteger(<span class="string">"10"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ch) &#123;</span><br><span class="line">            res = res.multiply(ten);</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'4'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'6'</span>)</span><br><span class="line">                    res = res.add(three);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = res.add(two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="You-Can-Go-Your-Own-Way"><a href="#You-Can-Go-Your-Own-Way" class="headerlink" title="You Can Go Your Own Way"></a>You Can Go Your Own Way</h3><blockquote><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><p>You have just entered the world’s easiest maze. You start in the northwest cell of an <strong>N</strong> by <strong>N</strong> grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid.</p><p>You are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above!</p><p>As an original thinker, you do not want to reuse any of Lydia’s moves. Specifically, if her path includes a unit move from some cell A to some adjacent cell B, your path cannot also include a move from A to B. (However, in that case, it is OK for your path to visit A or visit B, as long as you do not go from A to B.) Please find such a path.</p><p>In the following picture, Lydia’s path is indicated in blue, and one possible valid path for you is indicated in orange:</p><svg width="400px" height="400px" viewbox="0 0 502 502" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="color: rgb(32, 33, 36); font-family: Roboto; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: 0.1px; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="All" transform="translate(1.000000, 1.000000)"><g id="All-without-circles"><g id="Back" stroke-width="2" stroke="#000000"><g id="Group"><rect id="Rectangle-2" x="0" y="0" width="100" height="100"/><rect id="Rectangle-2" x="100" y="0" width="100" height="100"/><rect id="Rectangle-2" x="200" y="0" width="100" height="100"/><rect id="Rectangle-2" x="300" y="0" width="100" height="100"/><rect id="Rectangle-2" x="400" y="0" width="100" height="100"/></g><g id="Group" transform="translate(0.000000, 100.000000)"><rect id="Rectangle-2" x="0" y="0" width="100" height="100"/><rect id="Rectangle-2" x="100" y="0" width="100" height="100"/><rect id="Rectangle-2" x="200" y="0" width="100" height="100"/><rect id="Rectangle-2" x="300" y="0" width="100" height="100"/><rect id="Rectangle-2" x="400" y="0" width="100" height="100"/></g><g id="Group" transform="translate(0.000000, 200.000000)"><rect id="Rectangle-2" x="0" y="0" width="100" height="100"/><rect id="Rectangle-2" x="100" y="0" width="100" height="100"/><rect id="Rectangle-2" x="200" y="0" width="100" height="100"/><rect id="Rectangle-2" x="300" y="0" width="100" height="100"/><rect id="Rectangle-2" x="400" y="0" width="100" height="100"/></g><g id="Group" transform="translate(0.000000, 300.000000)"><rect id="Rectangle-2" x="0" y="0" width="100" height="100"/><rect id="Rectangle-2" x="100" y="0" width="100" height="100"/><rect id="Rectangle-2" x="200" y="0" width="100" height="100"/><rect id="Rectangle-2" x="300" y="0" width="100" height="100"/><rect id="Rectangle-2" x="400" y="0" width="100" height="100"/></g><g id="Group" transform="translate(0.000000, 400.000000)"><rect id="Rectangle-2" x="0" y="0" width="100" height="100"/><rect id="Rectangle-2" x="100" y="0" width="100" height="100"/><rect id="Rectangle-2" x="200" y="0" width="100" height="100"/><rect id="Rectangle-2" x="300" y="0" width="100" height="100"/><rect id="Rectangle-2" x="400" y="0" width="100" height="100"/></g></g><g id="Group-5" transform="translate(60.000000, 40.000000)"><path d="M0,10 L80,10" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(78.000000, 10.000000) rotate(-270.000000) translate(-78.000000, -10.000000) " points="78 0 88 20 68 20"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(190.000000, 98.000000) rotate(-180.000000) translate(-190.000000, -98.000000) " points="190 88 200 108 180 108"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(190.000000, 198.000000) rotate(-180.000000) translate(-190.000000, -198.000000) " points="190 188 200 208 180 208"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(190.000000, 298.000000) rotate(-180.000000) translate(-190.000000, -298.000000) " points="190 288 200 308 180 308"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(290.000000, 398.000000) rotate(-180.000000) translate(-290.000000, -398.000000) " points="290 388 300 408 280 408"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(178.000000, 10.000000) rotate(-270.000000) translate(-178.000000, -10.000000) " points="178 0 188 20 168 20"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(278.000000, 310.000000) rotate(-270.000000) translate(-278.000000, -310.000000) " points="278 300 288 320 268 320"/><polygon id="Triangle-2" fill="#4990E2" transform="translate(378.000000, 410.000000) rotate(-270.000000) translate(-378.000000, -410.000000) " points="378 400 388 420 368 420"/><path d="M100,10 L180,10" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M200,310 L280,310" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M300,410 L380,410" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M190,20 L190,100" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M190,120 L190,200" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M190,220 L190,300" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/><path d="M290,320 L290,400" id="Line" stroke="#4990E2" stroke-width="5" stroke-linecap="square"/></g><g id="Group-5" transform="translate(40.000000, 60.000000)" stroke="#F6A623"><path d="M20,90 L100,90" id="Line" stroke-width="5" stroke-linecap="square"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(98.000000, 90.000000) rotate(-270.000000) translate(-98.000000, -90.000000) " points="98 80 108 100 88 100"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(10.000000, 77.000000) rotate(-180.000000) translate(-10.000000, -77.000000) " points="10 67 20 87 0 87"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(310.000000, 177.000000) rotate(-180.000000) translate(-310.000000, -177.000000) " points="310 167 320 187 300 187"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(310.000000, 277.000000) rotate(-180.000000) translate(-310.000000, -277.000000) " points="310 267 320 287 300 287"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(410.000000, 377.000000) rotate(-180.000000) translate(-410.000000, -377.000000) " points="410 367 420 387 400 387"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(198.000000, 90.000000) rotate(-270.000000) translate(-198.000000, -90.000000) " points="198 80 208 100 188 100"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(398.000000, 290.000000) rotate(-270.000000) translate(-398.000000, -290.000000) " points="398 280 408 300 388 300"/><polygon id="Triangle-2" fill="#F6A623" transform="translate(298.000000, 90.000000) rotate(-270.000000) translate(-298.000000, -90.000000) " points="298 80 308 100 288 100"/><path d="M120,90 L200,90" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M220,90 L300,90" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M320,290 L400,290" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M10,0 L10,80" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M310,100 L310,180" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M310,200 L310,280" id="Line" stroke-width="5" stroke-linecap="square"/><path d="M410,300 L410,380" id="Line" stroke-width="5" stroke-linecap="square"/></g></g></g></g></defs></svg><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> test cases follow; each case consists of two lines. The first line contains one integer <strong>N</strong>, giving the dimensions of the maze, as described above. The second line contains a string <strong>P</strong>of 2<strong>N</strong> - 2 characters, each of which is either uppercase <code>E</code> (for east) or uppercase <code>S</code>(for south), representing Lydia’s valid path through the maze.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is a string of 2<strong>N</strong> - 2 characters each of which is either uppercase <code>E</code> (for east) or uppercase <code>S</code> (for south), representing your valid path through the maze that does not conflict with Lydia’s path, as described above. It is guaranteed that at least one answer exists.</p><h3 id="Limits-1"><a href="#Limits-1" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.<br>Time limit: 15 seconds per test set.<br>Memory limit: 1GB.<br><strong>P</strong> contains exactly <strong>N</strong> - 1 <code>E</code> characters and exactly <strong>N</strong> - 1 <code>S</code> characters.</p><h4 id="Test-set-1-Visible-1"><a href="#Test-set-1-Visible-1" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h4><p>2 ≤ <strong>N</strong> ≤ 10.</p><h4 id="Test-set-2-Visible-1"><a href="#Test-set-2-Visible-1" class="headerlink" title="Test set 2 (Visible)"></a>Test set 2 (Visible)</h4><p>2 ≤ <strong>N</strong> ≤ 1000.</p><h4 id="Test-set-3-Hidden-1"><a href="#Test-set-3-Hidden-1" class="headerlink" title="Test set 3 (Hidden)"></a>Test set 3 (Hidden)</h4><p>For at most 10 cases, 2 ≤ <strong>N</strong> ≤ 50000.<br>For all other cases, 2 ≤ <strong>N</strong> ≤ 10000.</p><h3 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h3><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td><code>2 2 SE 5 EESSSESE</code></td><td><code>Case #1: ES Case #2: SEEESSES</code></td></tr></tbody></table><p>In Sample Case #1, the maze is so small that there is only one valid solution left for us.</p><p>Sample Case #2 corresponds to the picture above. Notice that it is acceptable for the paths to cross.</p></blockquote><p>一开始我想的很复杂，回溯法解决：首先在<code>n*n</code>的格子上标记每个格子走的路线，如果遇到同路那就返回上一步换个方向继续做。时间和空间复杂度是$O(n^2)$，代码也很长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">1</span>; ti &lt;= t; ti++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">            String path = in.nextLine();</span><br><span class="line">            map = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">            res.clear();</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.length(); i++) &#123;</span><br><span class="line">                map[x][y] = path.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (path.charAt(i) == <span class="string">'E'</span>)</span><br><span class="line">                    y++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x++;</span><br><span class="line">            &#125;</span><br><span class="line">            findAnotherPath(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + ti + <span class="string">": "</span> + res.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findAnotherPath</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, StringBuilder curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = map.length;</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(curr.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> goEast = <span class="keyword">false</span>, goSouth = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (map[x][y] != <span class="string">'S'</span> &amp;&amp; y != n - <span class="number">1</span>) &#123;</span><br><span class="line">            curr.append(<span class="string">'S'</span>);</span><br><span class="line">            goEast = findAnotherPath(x, y + <span class="number">1</span>, curr);</span><br><span class="line">            curr.setLength(curr.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!goEast &amp;&amp; map[x][y] != <span class="string">'E'</span> &amp;&amp; x != n - <span class="number">1</span>) &#123;</span><br><span class="line">            curr.append(<span class="string">'E'</span>);</span><br><span class="line">            goSouth = findAnotherPath(x + <span class="number">1</span>, y, curr);</span><br><span class="line">            curr.setLength(curr.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goEast || goSouth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后顺利通过了两个visible case。</p><p>比赛结束之后，发现还有hidden case没过。看了一下analysis，才知道有一种更简洁的方法：</p><p>那就是始终走对称路线！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt(); <span class="comment">// Scanner has functions to read ints, longs, strings, chars, etc.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">1</span>; ti &lt;= t; ti++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">            String path = in.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + ti + <span class="string">": "</span> + inversePath(path));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">inversePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.length(); i++)</span><br><span class="line">            res.append(path.charAt(i) == <span class="string">'S'</span> ? <span class="string">'E'</span> : <span class="string">'S'</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cryptopangrams"><a href="#Cryptopangrams" class="headerlink" title="Cryptopangrams"></a>Cryptopangrams</h3><blockquote><h3 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h3><p>On the Code Jam team, we enjoy sending each other <em>pangrams</em>, which are phrases that use each letter of the English alphabet at least once. One common example of a pangram is “the quick brown fox jumps over the lazy dog”. Sometimes our pangrams contain confidential information — for example, <code>CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS</code> — so we need to keep them secure.</p><p>We looked through a cryptography textbook for a few minutes, and we learned that it is very hard to factor products of two large prime numbers, so we devised an encryption scheme based on that fact. First, we made some preparations:</p><ul><li>We chose 26 different prime numbers, none of which is larger than some integer <strong>N</strong>.</li><li>We sorted those primes in increasing order. Then, we assigned the smallest prime to the letter <code>A</code>, the second smallest prime to the letter <code>B</code>, and so on.</li><li>Everyone on the team memorized this list.</li></ul><p>Now, whenever we want to send a pangram as a message, we first remove all spacing to form a plaintext message. Then we write down the product of the prime for the first letter of the plaintext and the prime for the second letter of the plaintext. Then we write down the product of the primes for the second and third plaintext letters, and so on, ending with the product of the primes for the next-to-last and last plaintext letters. This new list of values is our ciphertext. The number of values is one smaller than the number of characters in the plaintext message.</p><p>For example, suppose that <strong>N</strong> = 103 and we chose to use the first 26 odd prime numbers, because we worry that it is too easy to factor even numbers. Then <code>A</code> = 3, <code>B</code> = 5, <code>C</code> = 7, <code>D</code> = 11, and so on, up to <code>Z</code> = 103. Also suppose that we want to encrypt the <code>CJ QUIZ</code>… pangram above, so our plaintext is <code>CJQUIZKNOWBEVYOFDPFLUXALGORITHMS</code>. Then the first value in our ciphertext is 7 (the prime for <code>C</code>) times 31 (the prime for <code>J</code>) = <code>217</code>; the next value is <code>1891</code>, and so on, ending with <code>3053</code>.</p><p>We will give you a ciphertext message and the value of <strong>N</strong> that we used. We will not tell you which primes we used, or how to decrypt the ciphertext. Do you think you can recover the plaintext anyway?</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> test cases follow; each test case consists of two lines. The first line contains two integers: <strong>N</strong>, as described above, and <strong>L</strong>, the length of the list of values in the ciphertext. The second line contains <strong>L</strong> integers: the list of values in the ciphertext.</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is a string of <strong>L</strong> + 1 uppercase English alphabet letters: the plaintext.</p><h3 id="Limits-2"><a href="#Limits-2" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.<br>Time limit: 20 seconds per test set.<br>Memory limit: 1 GB.<br>25 ≤ <strong>L</strong> ≤ 100.<br>The plaintext contains each English alphabet letter at least once.</p><h4 id="Test-set-1-Visible-2"><a href="#Test-set-1-Visible-2" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h4><p>101 ≤ <strong>N</strong> ≤ 10000.</p><h4 id="Test-set-2-Hidden"><a href="#Test-set-2-Hidden" class="headerlink" title="Test set 2 (Hidden)"></a>Test set 2 (Hidden)</h4><p>101 ≤ <strong>N</strong> ≤ 10100.</p><h3 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h3><table><thead><tr><th>Input</th><th></th></tr></thead><tbody><tr><td><code>2 103 31 217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053 10000 25 3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543</code></td><td></td></tr><tr><td></td><td></td></tr><tr><td>Output</td><td></td></tr><tr><td><code>Case #1: CJQUIZKNOWBEVYOFDPFLUXALGORITHMS Case #2: SUBDERMATOGLYPHICFJKNQVWXZ</code></td></tr></tbody></table></blockquote><p>思路很简单，找到两个相邻的数的最大公因数，例如相邻两个数是<code>a * b</code>和<code>b*c</code>，那么最大公因数就是<code>b</code></p><p>后面hidden case比较大，1e100的数据量，一开始先别考虑了</p><p>然后我就掉入了巨坑……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt(); <span class="comment">// Scanner has functions to read ints, longs, strings, chars, etc.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = in.nextInt(), len = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] products = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                products[j] = in.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + i + <span class="string">": "</span> + decrypt(len, products));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// greatest common divisor, using stein algorithm</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">            <span class="keyword">return</span> gcd(b, a);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> d1 = a &amp; <span class="number">1</span>, d2 = b &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (d1 == <span class="number">0</span> &amp;&amp; d2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * gcd(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> gcd(a - b, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] factor = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;Integer&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        factor[<span class="number">0</span>][<span class="number">1</span>] = gcd(product[<span class="number">0</span>], product[<span class="number">1</span>]);</span><br><span class="line">        factor[<span class="number">0</span>][<span class="number">0</span>] = product[<span class="number">0</span>] / factor[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        primes.add(factor[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            factor[i][<span class="number">0</span>] = factor[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            factor[i][<span class="number">1</span>] = product[i] / factor[i][<span class="number">0</span>];</span><br><span class="line">            primes.add(factor[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : primes)</span><br><span class="line">            nums.add(i);</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        Map&lt;Integer, Character&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            dict.put(nums.get(i), (<span class="keyword">char</span>)(<span class="string">'A'</span> + i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res.append(dict.get(factor[i][<span class="number">0</span>]));</span><br><span class="line">        res.append(dict.get(factor[n - <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单写了一下这个代码，上面gcd用的是欧几里得算法的加强版，对比较大的数提高了一点效率。</p><p>运行了一下sample，ok</p><p>结果在visible case上面<code>re(runtime error)</code>了。我寻思这也不是什么大的数据啊？？</p><p>冥思苦想，可能是数据太大溢出了？索性上<code>BigInteger</code>库吧，正好可以解决hidden case的问题。</p><p>用大整数库改写了一下代码，是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            BigInteger up = in.nextBigInteger();</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            BigInteger[] product = <span class="keyword">new</span> BigInteger[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                product[j] = in.nextBigInteger();</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + i + <span class="string">": "</span> + decrypt(n, product));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(<span class="keyword">int</span> n, BigInteger[] product)</span> </span>&#123;</span><br><span class="line">        BigInteger[][] factor = <span class="keyword">new</span> BigInteger[n][<span class="number">2</span>];</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;BigInteger&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        factor[<span class="number">0</span>][<span class="number">1</span>] = product[<span class="number">0</span>].gcd(product[<span class="number">1</span>]);</span><br><span class="line">        factor[<span class="number">0</span>][<span class="number">0</span>] = product[<span class="number">0</span>].divide(factor[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        primes.add(factor[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            factor[i][<span class="number">0</span>] = factor[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            factor[i][<span class="number">1</span>] = product[i].divide(factor[i][<span class="number">0</span>]);</span><br><span class="line">            primes.add(factor[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        primes.add(factor[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        List&lt;BigInteger&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;(primes);</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        Map&lt;BigInteger, Character&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            dict.put(nums.get(i), (<span class="keyword">char</span>) (<span class="string">'A'</span> + i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res.append(dict.get(factor[i][<span class="number">0</span>]));</span><br><span class="line">        res.append(dict.get(factor[n - <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自我感觉良好～sample ok之后就立马去attempt了。</p><p>结果：<code>RE</code></p><p>心态略崩，那说明不是我的问题咯？</p><p>于是去查了一下<code>RE</code>都有哪些错误——除了数组越界（这个不会吧，sample都过了），最可能的就是算数除0错误？</p><p>喵喵喵？哪里有0啊？</p><p>苦恼地改进了一下代码，把原来两行的数组改成一行了。话说本来就该用一行做的……</p><p>虽然很奇怪，但是我还是顺着这个想法，在代码中除的部分用了一次catch，捕捉之后返回错误的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(<span class="keyword">int</span> n, BigInteger[] product)</span> </span>&#123;</span><br><span class="line">    BigInteger[] factor = <span class="keyword">new</span> BigInteger[n + <span class="number">1</span>];</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Set&lt;BigInteger&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        factor[<span class="number">0</span>] = product[<span class="number">0</span>].divide(product[<span class="number">0</span>].gcd(product[<span class="number">1</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ERROR"</span>;<span class="comment">// 如果出现除0错误，那么提交结果就会变成WA</span></span><br><span class="line">    &#125;</span><br><span class="line">    primes.add(factor[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            factor[i + <span class="number">1</span>] = product[i].divide(factor[i]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;<span class="comment">// 如果出现除0错误，那么提交结果就会变成WA</span></span><br><span class="line">        &#125;</span><br><span class="line">        primes.add(factor[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    primes.add(factor[n]);</span><br><span class="line">    List&lt;BigInteger&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(primes);</span><br><span class="line">    Collections.sort(tmp);</span><br><span class="line">    Map&lt;BigInteger, Character&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++)</span><br><span class="line">        dict.put(tmp.get(i), (<span class="keyword">char</span>) (<span class="string">'A'</span> + i));</span><br><span class="line">    <span class="keyword">for</span> (BigInteger num : factor)</span><br><span class="line">        res.append(dict.getOrDefault(num, <span class="string">'@'</span>));</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次提交果然变成了<code>WA</code>，真的是除0的结果……</p><p>然而还是百思不得其解。</p><p>心态崩了一会，只好上ide了。</p><p>在intellij里面写了一下用0～1000的质数生成case的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">89</span>, <span class="number">109</span>, <span class="number">211</span>, <span class="number">239</span>, <span class="number">353</span>, <span class="number">479</span>, <span class="number">601</span>, <span class="number">701</span>, <span class="number">827</span>, <span class="number">883</span>, <span class="number">1021</span>, <span class="number">1051</span>, <span class="number">1087</span>, <span class="number">1277</span>, <span class="number">1381</span>, <span class="number">1531</span>, <span class="number">1571</span>, <span class="number">1669</span>, <span class="number">1861</span>, <span class="number">1973</span>, <span class="number">1997</span>, <span class="number">2137</span>, <span class="number">2213</span>, <span class="number">2281</span>, <span class="number">2411</span>&#125;;</span><br><span class="line">    Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>], product = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        dict.put((<span class="keyword">char</span>) (i + <span class="string">'A'</span>), nums[i]);</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>; ti &lt; n; ti++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) (<span class="string">'A'</span> + r.nextInt(<span class="number">26</span>));</span><br><span class="line">            res[i] = dict.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            product[i] = res[i] * res[i + <span class="number">1</span>];</span><br><span class="line">        System.out.println(<span class="string">"10000 "</span> + m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            System.out.print(product[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果做了几次实验，还真撞到一个error的case！</p><p>这还不赶紧保存下来，一看生成的case……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">10000</span> <span class="number">100</span></span><br><span class="line"><span class="number">4419361</span> <span class="number">4419361</span> <span class="number">2325863</span> <span class="number">1073071</span> <span class="number">2181877</span> <span class="number">4566769</span> <span class="number">4874497</span> <span class="number">4562</span> <span class="number">3994</span> <span class="number">2098847</span> <span class="number">371003</span> <span class="number">311699</span> <span class="number">618983</span> <span class="number">1498037</span> <span class="number">3566653</span> <span class="number">3338</span> <span class="number">4</span> <span class="number">706</span> <span class="number">704941</span> <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一个数和第二个数是相等的！这样一来它们的公因数就是本身——意味着我会认为第一个数对应的质数是1，第二个数的质数是它本身，第三个数的质数就是它除以第二个数，而如果它还比第二个数小，那么除法就会返回0！</p><p>终于想明白这一点之后，我开始思考解决方案：</p><ul><li>遇到这种情况，排列肯定出现了<code>aba</code>型的序列，导致前后两个乘积是相等的，得出的公因数就无效了。</li><li>每个字母在每段明文都出现至少一次，那么明文肯定出现了至少三个字母，那么肯定在某一处会有<code>abc</code>型的序列，他们保证乘积不相等。</li><li>那么就在找到不同的数之后，从他们入手解出公因数，然后向两侧【传播】。</li></ul><p>做到这点，终于做出了。比赛结束后一看，hidden case也搞定了，真不错。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O( n)$</p><p>最终完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            BigInteger up = in.nextBigInteger();</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            BigInteger[] product = <span class="keyword">new</span> BigInteger[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                product[j] = in.nextBigInteger();</span><br><span class="line">            System.out.println(<span class="string">"Case #"</span> + i + <span class="string">": "</span> + decrypt(n, product));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(<span class="keyword">int</span> n, BigInteger[] product)</span> </span>&#123;</span><br><span class="line">        BigInteger[] factor = <span class="keyword">new</span> BigInteger[n + <span class="number">1</span>];</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;BigInteger&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid &lt; n - <span class="number">1</span> &amp;&amp; product[mid].equals(product[mid + <span class="number">1</span>]))</span><br><span class="line">            mid++;</span><br><span class="line">        factor[mid] = product[mid].divide(product[mid].gcd(product[mid + <span class="number">1</span>]));</span><br><span class="line">        primes.add(factor[mid]);</span><br><span class="line">      <span class="comment">// 向右计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; n; i++) &#123;</span><br><span class="line">            factor[i + <span class="number">1</span>] = product[i].divide(factor[i]);</span><br><span class="line">            primes.add(factor[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 向左计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            factor[i - <span class="number">1</span>] = product[i - <span class="number">1</span>].divide(factor[i]);</span><br><span class="line">            primes.add(factor[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// set中质数排序后和对应字母构成字典</span></span><br><span class="line">        List&lt;BigInteger&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(primes);</span><br><span class="line">        Collections.sort(tmp);</span><br><span class="line">        Map&lt;BigInteger, Character&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++)</span><br><span class="line">            dict.put(tmp.get(i), (<span class="keyword">char</span>) (<span class="string">'A'</span> + i));</span><br><span class="line">      <span class="comment">// 这里以防万一嘛，虽然题目要求肯定不会出现get不到的字母</span></span><br><span class="line">        <span class="keyword">for</span> (BigInteger num : factor)</span><br><span class="line">            res.append(dict.getOrDefault(num, <span class="string">'@'</span>));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dat-Bae"><a href="#Dat-Bae" class="headerlink" title="Dat Bae"></a>Dat Bae</h3><blockquote><h3 id="Problem-3"><a href="#Problem-3" class="headerlink" title="Problem"></a>Problem</h3><p>A research consortium has built a new database system for their new data center. The database is made up of one master computer and <strong>N</strong> worker computers, which are given IDs from 0 to <strong>N</strong>-1. Each worker stores exactly one bit of information… which seems rather wasteful, but this is very important data!</p><p>You have been hired to evaluate the following instruction for the database:</p><ul><li><code>TEST_STORE</code> <bits>: The master reads in <bits>, which is a string of <strong>N</strong> bits, and sends the i-th bit to the i-th worker for storage. The master will then read the bits back from the workers and return them to the user, in the same order in which they were read in.</bits></bits></li></ul><p>During normal operation, <code>TEST_STORE</code> should return the same string of bits that it read in, but unfortunately, <strong>B</strong> of the workers are broken!</p><p>The broken workers are correctly able to store the bits given to them, but whenever the master tries to read from a broken worker, no bit is returned. This causes the <code>TEST_STORE</code> operation to return only <strong>N</strong>-<strong>B</strong> bits, which are the bits stored on the non-broken workers (in ascending order of their IDs). For example, suppose <strong>N</strong> = 5 and the 0th and 3rd workers are broken (so <strong>B</strong> = 2). Then:</p><ul><li><code>TEST_STORE 01101</code> returns <code>111</code>.</li><li><code>TEST_STORE 00110</code> returns <code>010</code>.</li><li><code>TEST_STORE 01010</code> returns <code>100</code>.</li><li><code>TEST_STORE 11010</code> also returns <code>100</code>.</li></ul><p>For security reasons, the database is hidden in an underground mountain vault, so calls to <code>TEST_STORE</code> take a very long time. You have been tasked with working out which workers are broken using at most <strong>F</strong> calls to <code>TEST_STORE</code>.</p><h3 id="Input-and-output"><a href="#Input-and-output" class="headerlink" title="Input and output"></a>Input and output</h3><p>This is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our <a href="https://codingcompetitions.withgoogle.com/codejam/faq" target="_blank" rel="noopener">FAQ</a>.</p><p>Initially, your program should read a single line containing a single integer <strong>T</strong>indicating the number of test cases. Then, you need to process <strong>T</strong> test cases.</p><p>For each test case, your program will first read a single line containing three integers <strong>N</strong>, <strong>B</strong>, and <strong>F</strong>, indicating the number of workers, the number of broken workers, and the number of lines you may send (as described below).</p><p>Then you may send the judge up to <strong>F</strong> lines, each containing a string of exactly <strong>N</strong>characters, each either <code>0</code> or <code>1</code>. Each time you send a line, the judge will check that you have not made more than <strong>F</strong> calls. If you have, the judge will send you a single line containing a single <code>-1</code>, and then finish all communication and wait for your program to finish. Otherwise, the judge will send a string of length <strong>N</strong>-<strong>B</strong>: the string returned by <code>TEST_STORE</code>, as described above.</p><p>Once your program knows the index of the <strong>B</strong> broken workers, it can finish the test case by sending <strong>B</strong> space-separated integers: the IDs of the broken workers, in sorted order. This does not count as one of your <strong>F</strong> calls.</p><p>If the <strong>B</strong> integers are not exactly the IDs of the <strong>B</strong> broken workers, you will receive a Wrong Answer verdict, and the judge will send a single line containing <code>-1</code>, and then no additional communication. If your answer was correct, the judge will send a single line with <code>1</code>, followed by the line that begins the next test case (or exit, if that was the last test case).</p><h3 id="Limits-3"><a href="#Limits-3" class="headerlink" title="Limits"></a>Limits</h3><p>Time limit: 20 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ <strong>T</strong> ≤ 100.<br>2 ≤ <strong>N</strong> ≤ 1024.<br>1 ≤ <strong>B</strong> ≤ min(15, <strong>N</strong>-1).</p><h4 id="Test-set-1-Visible-3"><a href="#Test-set-1-Visible-3" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h4><p><strong>F</strong> = 10.</p><h4 id="Test-set-2-Hidden-1"><a href="#Test-set-2-Hidden-1" class="headerlink" title="Test set 2 (Hidden)"></a>Test set 2 (Hidden)</h4><p><strong>F</strong> = 5.</p><h3 id="Testing-Tool"><a href="#Testing-Tool" class="headerlink" title="Testing Tool"></a>Testing Tool</h3><p>You can use this testing tool to test locally or on our servers. To test locally, you will need to run the tool in parallel with your code; you can use our <a href="https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py" target="_blank" rel="noopener">interactive runner</a> for that. For more information, read the Interactive Problems section of the <a href="https://codingcompetitions.withgoogle.com/codejam/faq" target="_blank" rel="noopener">FAQ</a>.</p><h3 id="Local-Testing-Tool"><a href="#Local-Testing-Tool" class="headerlink" title="Local Testing Tool"></a>Local Testing Tool</h3><p>To better facilitate local testing, we provide you the following script. Instructions are included inside. You are encouraged to add more test cases for better testing. Please be advised that although the testing tool is intended to simulate the judging system, it is <strong>NOT</strong> the real judging system and might behave differently.</p><p>If your code passes the testing tool but fails the real judge, please check <a href="https://code.google.com/codejam/resources/faq#language-details" target="_blank" rel="noopener">here</a> to make sure that you are using the same compiler as us.</p><p><a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de#" target="_blank" rel="noopener"><em>file_download</em>Download testing_tool.py</a></p><h3 id="Sample-Interaction"><a href="#Sample-Interaction" class="headerlink" title="Sample Interaction"></a>Sample Interaction</h3><p>The following interaction meets the limits for Test set 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;   t = readline_int()           // Reads <span class="number">2</span> into t</span><br><span class="line">&gt;   n, b, f = readline_int_list()  // Reads <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span> into n, b, f</span><br><span class="line">&gt;   printline <span class="number">01101</span> to stdout    // The next four outputs match the example <span class="keyword">in</span></span><br><span class="line">&gt;                                // the problem statement.</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   response = readline_str()    // Reads <span class="number">111</span> into response. (At this point, we</span><br><span class="line">&gt;                                // could determine the answer; the remaining</span><br><span class="line">&gt;                                // queries are just examples!)</span><br><span class="line">&gt;   printline <span class="number">00110</span> to stdout</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   response = readline_str()    // Reads <span class="number">010</span> into response</span><br><span class="line">&gt;   printline <span class="number">01010</span> to stdout</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   response = readline_str()    // Reads <span class="number">100</span> into response</span><br><span class="line">&gt;   printline <span class="number">11010</span> to stdout</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   response = readline_str()    // Reads <span class="number">100</span> into response</span><br><span class="line">&gt;   printline <span class="number">0</span> <span class="number">3</span> to stdout      // Guesses the answer. Notice that we were</span><br><span class="line">&gt;                                // <span class="keyword">not</span> required to use all <span class="number">10</span> of our allowed</span><br><span class="line">&gt;                                // queries.</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   verdict = readline_int()     // Reads <span class="number">1</span> into verdict. We got that test case</span><br><span class="line">&gt;                                // right!</span><br><span class="line">&gt;   n, b, f = readline_int_list()  // Reads <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span> into n, b, f.</span><br><span class="line">&gt;   printline <span class="number">01</span> to stdout       // <span class="number">01</span> <span class="keyword">is</span> a query, <span class="keyword">not</span> a guess at the final</span><br><span class="line">&gt;                                // answer (<span class="keyword">if</span> we wanted to guess that just</span><br><span class="line">&gt;                                // worker <span class="number">1</span> were broken, we would have to</span><br><span class="line">&gt;                                // send <span class="number">1</span> <span class="keyword">as</span> we do below)</span><br><span class="line">&gt;   flush stdout</span><br><span class="line">&gt;   response = readline_str()    // Reads <span class="number">1</span> into response.</span><br><span class="line">&gt;   printline <span class="number">1</span> to stdout        // Makes a (bad) wild guess.</span><br><span class="line">&gt;   verdict = readline_str()     // Reads <span class="number">-1</span> into verdict.</span><br><span class="line">&gt;   exit                         // exits to avoid an ambiguous TLE error</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这题比赛的时候没有做，现在研究一下。</p><p>少见的交互题，其实就是和控制台输入输出的交互。</p><p>说的是如何在有限次收发信息中确定缺失的机子有哪些。</p><p>先占坑，待补充代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备打一下今年的code jam和kick start，看了一下code jam是采取连续比赛的机制，kick start是每一轮独立。&lt;/p&gt;
&lt;p&gt;今天写一下关于code jam的资格赛的事情。&lt;/p&gt;
&lt;p&gt;QR在4月5日早上七点开始，持续27小时，只要在难度不大的四题（总分100）里面做出30分就可以。&lt;/p&gt;
&lt;p&gt;贴一下战绩：55分，其实挺低的……还需要加油&lt;/p&gt;
    
    </summary>
    
      <category term="competition" scheme="http://yoursite.com/categories/competition/"/>
    
    
      <category term="code jam" scheme="http://yoursite.com/tags/code-jam/"/>
    
  </entry>
  
  <entry>
    <title>ML学习日记——梯度下降技巧</title>
    <link href="http://yoursite.com/2019/04/03/ML-3-Gradient-Descent/"/>
    <id>http://yoursite.com/2019/04/03/ML-3-Gradient-Descent/</id>
    <published>2019-04-03T15:54:09.000Z</published>
    <updated>2019-04-07T08:33:35.641Z</updated>
    
    <content type="html"><![CDATA[<p>一些改进梯度下降方法的要点。</p><a id="more"></a><h3 id="自适应学习率：Adagrad-learning-rate"><a href="#自适应学习率：Adagrad-learning-rate" class="headerlink" title="自适应学习率：Adagrad learning rate"></a>自适应学习率：Adagrad learning rate</h3><ul><li>学习率太大或者太小，都会导致问题<ul><li>太小会收敛过慢</li><li>太大会不收敛</li></ul></li><li>自适应学习率可以较好地改变情况</li></ul><p><img src="/2019/04/03/ML-3-Gradient-Descent/IMG_2209.PNG" alt="IMG_2209"></p><p><img src="/2019/04/03/ML-3-Gradient-Descent/IMG_2210.PNG" alt="IMG_2210"></p><p><img src="/2019/04/03/ML-3-Gradient-Descent/IMG_2211.PNG" alt="IMG_2211"></p><h3 id="随机梯度下降：Stochastic-gradient-descent"><a href="#随机梯度下降：Stochastic-gradient-descent" class="headerlink" title="随机梯度下降：Stochastic gradient descent"></a>随机梯度下降：Stochastic gradient descent</h3><ul><li>每次选取少量样本进行梯度下降</li><li>每一步未必朝着正确的方向，但是在全局一步的时间里可以进行多次迭代从而到达终点</li></ul><h3 id="特征归一化：Feature-scaling"><a href="#特征归一化：Feature-scaling" class="headerlink" title="特征归一化：Feature scaling"></a>特征归一化：Feature scaling</h3><ul><li>将所有维度统一到0和1（作为例子）的尺度，避免单一维度的weight变化影响全局太多或者太少</li></ul><p><img src="/2019/04/03/ML-3-Gradient-Descent/IMG_2212.PNG" alt="IMG_2212"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些改进梯度下降方法的要点。&lt;/p&gt;
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="gradient descent" scheme="http://yoursite.com/tags/gradient-descent/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft 2019暑期OA题目</title>
    <link href="http://yoursite.com/2019/04/03/Microsoft-2019%E6%9A%91%E6%9C%9FOA%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/04/03/Microsoft-2019暑期OA题目/</id>
    <published>2019-04-03T15:17:29.000Z</published>
    <updated>2019-04-03T15:28:13.640Z</updated>
    
    <content type="html"><![CDATA[<p>做了一晚上，心态崩了。。两小时4题，这难度堪比acm。</p><a id="more"></a><p>不说了，下面贴题目吧：</p><h3 id="Playing-with-beads"><a href="#Playing-with-beads" class="headerlink" title="Playing with beads"></a>Playing with beads</h3><blockquote><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/1-1.png" alt="1-1"></p><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/1-2.png" alt="1-2"></p></blockquote><h3 id="Archer"><a href="#Archer" class="headerlink" title="Archer"></a>Archer</h3><blockquote><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/2-1.png" alt="2-1"></p><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/2-2.png" alt="2-2"></p></blockquote><h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><blockquote><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/3-1.png" alt="3-1"></p><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/3-2.png" alt="3-2"></p></blockquote><h3 id="Honey-Madness"><a href="#Honey-Madness" class="headerlink" title="Honey Madness"></a>Honey Madness</h3><blockquote><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/4-1.png" alt="4-1"></p><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/4-2.png" alt="4-2"></p><p><img src="/2019/04/03/Microsoft-2019暑期OA题目/4-3.png" alt="4-3"></p></blockquote><p>做出了1和3（但也不是全对），2和4完全没有思路。佛了。</p><p>之后如果有机会再补上吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了一晚上，心态崩了。。两小时4题，这难度堪比acm。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://yoursite.com/categories/interview/"/>
    
    
      <category term="intern" scheme="http://yoursite.com/tags/intern/"/>
    
      <category term="oa" scheme="http://yoursite.com/tags/oa/"/>
    
      <category term="microsoft" scheme="http://yoursite.com/tags/microsoft/"/>
    
  </entry>
  
  <entry>
    <title>ML学习日记——泛化误差：方差与偏差</title>
    <link href="http://yoursite.com/2019/04/02/ML-2-Variance-and-Bias/"/>
    <id>http://yoursite.com/2019/04/02/ML-2-Variance-and-Bias/</id>
    <published>2019-04-02T13:29:51.000Z</published>
    <updated>2019-04-03T15:50:43.651Z</updated>
    
    <content type="html"><![CDATA[<p>首先引用一段<a href="https://zhuanlan.zhihu.com/p/38853908" target="_blank" rel="noopener">知乎</a>上的描述：</p><blockquote><p>在机器学习中，我们用训练数据集去训练一个模型，通常的做法是定义一个误差函数，通过将这个误差的最小化过程，来提高模型的性能。</p><p>然而我们学习一个模型的目的是为了解决训练数据集这个领域中的一般化问题，单纯地将训练数据集的损失最小化，并不能保证在解决更一般的问题时模型仍然是最优，甚至不能保证模型是可用的。这个训练数据集的损失与一般化的数据集的损失之间的差异就叫做<strong>泛化误差（generalization error）</strong>。</p><p>泛化误差为偏差、方差与噪声之和。</p></blockquote><a id="more"></a><h3 id="Variance（方差）"><a href="#Variance（方差）" class="headerlink" title="Variance（方差）"></a>Variance（方差）</h3><ul><li><strong>Variance</strong>是<strong>不同的训练数据集训练出的模型</strong>输出值之间的差异。</li><li>越复杂的模型，它的variance就越大，表现出来就是过拟合。</li><li>越简单的模型，variance越小</li><li><strong>方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</strong></li><li>解决方案：<ol><li>collect more data，至少不会让variance更大；但是一般比较难获得（可以从现有数据修改等获得）。</li><li>或者使用regularization，使曲线平滑；代价是增大bias。</li></ol></li></ul><h3 id="Bias（偏差）"><a href="#Bias（偏差）" class="headerlink" title="Bias（偏差）"></a>Bias（偏差）</h3><ul><li><strong>Bias</strong>是用<strong>所有可能的训练数据集</strong>训练出的<strong>所有模型</strong>的输出的<strong>平均值</strong>与<strong>真实模型</strong>的输出值之间的差异。</li><li>比较简单的模型，bias越大，表现出来是underfitting</li><li>较大的bias说明甚至没有很好拟合training data</li></ul><h3 id="Noise（噪声）"><a href="#Noise（噪声）" class="headerlink" title="Noise（噪声）"></a>Noise（噪声）</h3><ul><li><strong>噪声</strong>的存在是学习算法所无法解决的问题，数据的质量决定了学习的上限。假设在数据已经给定的情况下，此时上限已定，我们要做的就是尽可能的接近这个上限。</li></ul><hr><h3 id="Cross-Validation"><a href="#Cross-Validation" class="headerlink" title="Cross Validation"></a>Cross Validation</h3><p>待补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先引用一段&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38853908&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt;上的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在机器学习中，我们用训练数据集去训练一个模型，通常的做法是定义一个误差函数，通过将这个误差的最小化过程，来提高模型的性能。&lt;/p&gt;
&lt;p&gt;然而我们学习一个模型的目的是为了解决训练数据集这个领域中的一般化问题，单纯地将训练数据集的损失最小化，并不能保证在解决更一般的问题时模型仍然是最优，甚至不能保证模型是可用的。这个训练数据集的损失与一般化的数据集的损失之间的差异就叫做&lt;strong&gt;泛化误差（generalization error）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;泛化误差为偏差、方差与噪声之和。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="regression" scheme="http://yoursite.com/tags/regression/"/>
    
  </entry>
  
  <entry>
    <title>ML学习日记——线性回归与梯度下降</title>
    <link href="http://yoursite.com/2019/04/02/ML-1-LinearRegression/"/>
    <id>http://yoursite.com/2019/04/02/ML-1-LinearRegression/</id>
    <published>2019-04-01T18:30:29.000Z</published>
    <updated>2019-04-05T16:13:06.764Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习台大李宏毅教授的机器学习视频。</p><p>这篇文章是自己写的一个简单的多元线性回归模型：$y = \sum{w_i*x_i}+b$，基于批量梯度下降方法。</p><a id="more"></a><h3 id="准备阶段：生成训练数据和测试数据，选取多元一次的线性关系"><a href="#准备阶段：生成训练数据和测试数据，选取多元一次的线性关系" class="headerlink" title="准备阶段：生成训练数据和测试数据，选取多元一次的线性关系"></a>准备阶段：生成训练数据和测试数据，选取多元一次的线性关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成train data和test data</span></span><br><span class="line"><span class="comment"># 随机选择一些x和w，b</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, uniform</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genCase</span><span class="params">(n: int, m: int)</span>:</span></span><br><span class="line">    x = random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (m, n))</span><br><span class="line">    w = random.uniform(<span class="number">0</span>, <span class="number">10</span>, (n, <span class="number">1</span>))</span><br><span class="line">    b = uniform(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 加入噪音</span></span><br><span class="line">    y = [sum(x[i1].dot(w)) + b + uniform(<span class="number">-0.5</span>, <span class="number">0.5</span>) <span class="keyword">for</span> i1 <span class="keyword">in</span> range(len(x))]</span><br><span class="line">    print(<span class="string">"Generated %d cases with %d features."</span> % (m, n))</span><br><span class="line">    <span class="keyword">return</span> x, y, w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitCase</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    <span class="keyword">if</span> len(y) != n:</span><br><span class="line">        <span class="keyword">return</span> [], [], [], []</span><br><span class="line">    trainX, trainY, testX, testY = [], [], [], []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> randint(<span class="number">1</span>, <span class="number">4</span>) &gt; <span class="number">2</span>:</span><br><span class="line">            testX.append(x[j])</span><br><span class="line">            testY.append(y[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            trainX.append(x[j])</span><br><span class="line">            trainY.append(y[j])</span><br><span class="line">    print(<span class="string">"Split data into 2 parts: %d train data and %d test data"</span> % (len(trainX), len(testX)))</span><br><span class="line">    <span class="keyword">return</span> trainX, trainY, testX, testY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X, Y, OriginW, OriginB = genCase(<span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">TrainX, TrainY, TestX, TestY = splitCase(X, Y)</span><br><span class="line"><span class="comment"># 导出到文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./data/train.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(TrainX)):</span><br><span class="line">        f.write(<span class="string">'\t'</span>.join(list(map(str, TrainX[i]))) + <span class="string">'\t'</span> + str(TrainY[i]) + <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./data/test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(TestX)):</span><br><span class="line">        f.write(<span class="string">'\t'</span>.join(list(map(str, TestX[i]))) + <span class="string">'\t'</span> + str(TestY[i]) + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generated 1000 cases with 10 features.</span><br><span class="line">Split data into 2 parts: 484 train data and 516 test data</span><br></pre></td></tr></table></figure><h3 id="训练阶段：采用批量梯度下降方法拟合"><a href="#训练阶段：采用批量梯度下降方法拟合" class="headerlink" title="训练阶段：采用批量梯度下降方法拟合"></a>训练阶段：采用批量梯度下降方法拟合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> loadtxt, ones</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x, w, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(x.dot(w)) + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(x, y, w, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([(h(x[i1], w, b) - y[i1]) ** <span class="number">2</span> <span class="keyword">for</span> i1 <span class="keyword">in</span> range(len(x))])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batchGradientDescent</span><span class="params">(x, y, rate=<span class="number">0.1</span>, iterBound=<span class="number">100000</span>, gradBound=<span class="number">1e-6</span>)</span>:</span></span><br><span class="line">    m = len(x)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> len(y) != m:</span><br><span class="line">        <span class="keyword">return</span> [], <span class="number">-1</span></span><br><span class="line">    n = len(x[<span class="number">0</span>])</span><br><span class="line">    w, b = ones((n, <span class="number">1</span>)), <span class="number">1</span></span><br><span class="line">    print(<span class="string">"Learning ratio: %f"</span> % rate)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(iterBound):</span><br><span class="line">        gradW = [sum([x[i][j] * (y[i] - h(x[i], w, b)) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]) / m <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line">        gradB = sum([(y[i] - h(x[i], w, b)) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]) / m</span><br><span class="line">        <span class="comment"># 跳出循环的条件：梯度值较小</span></span><br><span class="line">        <span class="keyword">if</span> abs(gradB) &lt;= gradBound:</span><br><span class="line">            print(<span class="string">"Converges after %d rounds of batch gradient descent."</span> % k)</span><br><span class="line">            <span class="keyword">return</span> w, b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            w[i] += gradW[i] * rate</span><br><span class="line">        b += gradB * rate</span><br><span class="line">    print(<span class="string">"After %d rounds of gradient descent, the loss is %f"</span> % (k, loss(x, y, w, b)))</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span><span class="params">(file: str)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = loadtxt(f)</span><br><span class="line">    <span class="keyword">return</span> [data[i1][:<span class="number">-1</span>] <span class="keyword">for</span> i1 <span class="keyword">in</span> range(len(data))], [data[i1][<span class="number">-1</span>] <span class="keyword">for</span> i1 <span class="keyword">in</span> range(len(data))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trainX, trainY = readData(<span class="string">"./data/train.txt"</span>)</span><br><span class="line">testX, testY = readData(<span class="string">"./data/test.txt"</span>)</span><br><span class="line">%time W, B = batchGradientDescent(trainX, trainY, <span class="number">0.02</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Learning ratio: 0.020000</span><br><span class="line">Converges after 608 rounds of batch gradient descent.</span><br><span class="line">CPU times: user 5.72 s, sys: 23 ms, total: 5.75 s</span><br><span class="line">Wall time: 5.76 s</span><br></pre></td></tr></table></figure><h3 id="预测阶段：使用test数据测试模型准确率"><a href="#预测阶段：使用test数据测试模型准确率" class="headerlink" title="预测阶段：使用test数据测试模型准确率"></a>预测阶段：使用test数据测试模型准确率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Loss for test data: %f"</span> % loss(testX, testY, W, B))</span><br><span class="line">print(<span class="string">"Loss for test data with original w and b: %f"</span> % loss(testX, testY, OriginW, OriginB))</span><br><span class="line">print(<span class="string">"Difference for w and b:"</span>, OriginW - W, OriginB - B)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Loss for test data: 47.161984</span><br><span class="line">Loss for test data with original w and b: 46.188546</span><br><span class="line">Difference for w and b: [[-0.00095575]</span><br><span class="line"> [ 0.0001872 ]</span><br><span class="line"> [ 0.00153668]</span><br><span class="line"> [ 0.00050082]</span><br><span class="line"> [-0.00034511]</span><br><span class="line"> [-0.00396764]</span><br><span class="line"> [-0.00295501]</span><br><span class="line"> [ 0.00099687]</span><br><span class="line"> [ 0.00369943]</span><br><span class="line"> [ 0.00379453]] -0.003807025307413836</span><br></pre></td></tr></table></figure><ul><li>经过梯度下降之后，达到了较好的精度。</li><li>时间上存在改进空间。</li></ul><h3 id="自适应learning-rate：Adagrad"><a href="#自适应learning-rate：Adagrad" class="headerlink" title="自适应learning rate：Adagrad"></a>自适应learning rate：Adagrad</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improvedBGD</span><span class="params">(x, y, iterBound=<span class="number">10000</span>, gradBound=<span class="number">1e-6</span>)</span>:</span></span><br><span class="line">    m = len(x)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> len(y) != m:</span><br><span class="line">        <span class="keyword">return</span> [], <span class="number">-1</span></span><br><span class="line">    n = len(x[<span class="number">0</span>])</span><br><span class="line">    w, b = ones((n, <span class="number">1</span>)), <span class="number">1</span></span><br><span class="line">    rateW, rateB = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k1 <span class="keyword">in</span> range(iterBound):</span><br><span class="line">        gradW = [sum([x[i][j] * (y[i] - h(x[i], w, b)) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]) / m <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line">        gradB = sum([(y[i] - h(x[i], w, b)) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]) / m</span><br><span class="line">        <span class="comment"># 跳出循环的条件：梯度值较小</span></span><br><span class="line">        <span class="keyword">if</span> abs(gradB) &lt;= gradBound:</span><br><span class="line">            print(<span class="string">"Converges after %d rounds of batch gradient descent."</span> % k1)</span><br><span class="line">            <span class="keyword">return</span> w, b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            rateW[i] += gradW[i] ** <span class="number">2</span></span><br><span class="line">            w[i] += gradW[i] / sqrt(rateW[i])</span><br><span class="line">        rateB += gradB ** <span class="number">2</span></span><br><span class="line">        b += gradB / sqrt(rateB)</span><br><span class="line">    print(<span class="string">"After %d rounds of gradient descent, the loss is %f"</span> % (k1, loss(x, y, w, b)))</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">%time W, B = improvedBGD(trainX, trainY)</span><br><span class="line">print(<span class="string">"Loss for test data: %f"</span> % loss(testX, testY, W, B))</span><br><span class="line">print(<span class="string">"Loss for test data with original w and b: %f"</span> % loss(testX, testY, OriginW, OriginB))</span><br><span class="line">print(<span class="string">"Difference for w and b:"</span>, OriginW - W, OriginB - B)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Converges after 251 rounds of batch gradient descent.</span><br><span class="line">CPU times: user 2.55 s, sys: 9.66 ms, total: 2.56 s</span><br><span class="line">Wall time: 2.57 s</span><br><span class="line">Loss for test data: 43.177537</span><br><span class="line">Loss for test data with original w and b: 41.600574</span><br><span class="line">Difference for w and b: [[ 0.00108563]</span><br><span class="line"> [-0.00580816]</span><br><span class="line"> [ 0.00122102]</span><br><span class="line"> [-0.002008  ]</span><br><span class="line"> [-0.00198998]</span><br><span class="line"> [-0.0003545 ]</span><br><span class="line"> [ 0.00242942]</span><br><span class="line"> [-0.00419475]</span><br><span class="line"> [-0.00064363]</span><br><span class="line"> [ 0.00016461]] -0.009286649191009438</span><br></pre></td></tr></table></figure><h3 id="使用高次拟合，查看loss变化"><a href="#使用高次拟合，查看loss变化" class="headerlink" title="使用高次拟合，查看loss变化"></a>使用高次拟合，查看loss变化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateAll</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    res = ones((len(x), n * len(x[<span class="number">0</span>])))</span><br><span class="line">    count = len(x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i1 <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">for</span> j1 <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> k1 <span class="keyword">in</span> range(count):</span><br><span class="line">                res[i1][k1 + j1 * count] = x[i1][k1] ** (j1 + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合过程可以直接使用batchGradientDescent函数解决</span></span><br><span class="line"><span class="comment"># 为了节约时间（一方面learning rate不能高，一高就不收敛；另一方面太低可能半小时都跑不出来）</span></span><br><span class="line">trainLoss = [loss(trainX, trainY, W, B)]</span><br><span class="line">testLoss = [loss(testX, testY, W, B)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    exTrainX, exTestX = generateAll(trainX, i), generateAll(testX, i)</span><br><span class="line">    %time Wi, Bi = improvedBGD(exTrainX, trainY)</span><br><span class="line">    trainLoss.append(loss(exTrainX, trainY, Wi, Bi))</span><br><span class="line">    testLoss.append(loss(exTestX, testY, Wi, Bi))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">After 9999 rounds of gradient descent, the loss is 36.904122</span><br><span class="line">CPU times: user 3min 50s, sys: 1.34 s, total: 3min 51s</span><br><span class="line">Wall time: 3min 52s</span><br><span class="line">After 9999 rounds of gradient descent, the loss is 35.874497</span><br><span class="line">CPU times: user 5min 39s, sys: 1.56 s, total: 5min 40s</span><br><span class="line">Wall time: 5min 42s</span><br><span class="line">After 9999 rounds of gradient descent, the loss is 261.607271</span><br><span class="line">CPU times: user 7min 28s, sys: 2.38 s, total: 7min 31s</span><br><span class="line">Wall time: 7min 33s</span><br><span class="line">After 9999 rounds of gradient descent, the loss is 181030.524181</span><br><span class="line">CPU times: user 9min 20s, sys: 3.25 s, total: 9min 24s</span><br><span class="line">Wall time: 9min 27s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> arange</span><br><span class="line"></span><br><span class="line">x_axis = arange(len(trainLoss))</span><br><span class="line">plt.axis(<span class="string">'on'</span>)</span><br><span class="line">plt.plot(x_axis, trainLoss, label=<span class="string">'train'</span>)</span><br><span class="line">plt.plot(x_axis, testLoss, label=<span class="string">'test'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/ML-1-LinearRegression/LinearRegression.png" alt="png"></p><ul><li>出现了明显的overfitting现象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(testLoss)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[43.17753677246426, 46.221044463400624, 47.5150256435928, 295.13051190429354, 216220.90071215943]</span><br></pre></td></tr></table></figure><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><h4 id="减少变量"><a href="#减少变量" class="headerlink" title="减少变量"></a>减少变量</h4><p>可以人工检查每一项变量，保留重要的变量。</p><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>过拟合之后，可以采用<code>regularization</code>方法，加入新的一项：$\lambda * \sum{w^2_i}$</p><p>这一项表示曲线的平滑程度：</p><ul><li>如果这一项越小，那么对输入的小幅度变化越不敏感，所以在小范围内波动比较稳定，不会偏离太多，从而对噪声不敏感，做到更好的拟合。</li><li><p>本质是对高次项作出惩罚，因为所有的w都是一样的系数，但是惩罚项带来变化对高次项影响更大。</p></li><li><p>随着$\lambda​$值变大而变得平滑，拟合度更高；但是高到一定程度的时候，引入的项造成的error越大。我们当然不喜欢太平滑的函数，极端一点就变成水平直线，没有任何意义。</p></li><li><p>这一项不需要加入<code>bias</code>这一项——因为它是常数项，只会把曲线抬高，不会影响曲线的形状。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始学习台大李宏毅教授的机器学习视频。&lt;/p&gt;
&lt;p&gt;这篇文章是自己写的一个简单的多元线性回归模型：$y = \sum{w_i*x_i}+b$，基于批量梯度下降方法。&lt;/p&gt;
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="regression" scheme="http://yoursite.com/tags/regression/"/>
    
      <category term="gradient descent" scheme="http://yoursite.com/tags/gradient-descent/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>VOI</title>
    <link href="http://yoursite.com/2019/03/28/VOI/"/>
    <id>http://yoursite.com/2019/03/28/VOI/</id>
    <published>2019-03-28T13:27:59.000Z</published>
    <updated>2019-04-02T10:58:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>VOI：一个来自iOS应用移植的小游戏，主体在canvas实现(^ _ ^)<br>点击👉<a href="/voi/index.html">这里</a><br>也可以在左侧边栏找到<br>代码在<a href="https://github.com/Riroaki/VOI" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;VOI：一个来自iOS应用移植的小游戏，主体在canvas实现(^ _ ^)&lt;br&gt;点击👉&lt;a href=&quot;/voi/index.html&quot;&gt;这里&lt;/a&gt;&lt;br&gt;也可以在左侧边栏找到&lt;br&gt;代码在&lt;a href=&quot;https://github.com/Riroaki/VO
      
    
    </summary>
    
      <category term="wheels" scheme="http://yoursite.com/categories/wheels/"/>
    
    
  </entry>
  
  <entry>
    <title>Google实习面试经历</title>
    <link href="http://yoursite.com/2019/03/28/Google%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2019/03/28/Google实习面试经历/</id>
    <published>2019-03-27T17:55:55.000Z</published>
    <updated>2019-04-02T12:04:55.625Z</updated>
    
    <content type="html"><![CDATA[<ul><li>3月29更新：</li></ul><blockquote><p><strong>Your Current Stage:</strong>  Pending. Unfortunately, your current interview result is not strong enough to proceed to next step, we will try to strive opportunity for you. If there is any update about proceed or reject, I’ll definitely let you know.</p></blockquote><p>今天发邮件催了一下hr，对面表示面试成绩不够好被挂着，然而也没有直接刷……学长说其实基本就是算凉了，我也不抱希望。</p><p>总体来说二面发挥较好，一面比较失败。等有空再补一下这两次面试的经历。</p><p>还是希望有加面的机会啊……毕竟准备了两个月刷leetcode（虽然还是很菜）<br><a id="more"></a></p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>上来先自我介绍，然而我并没有好好准备这部分，并没有说明自己的项目经历等等……现在看来真的太蠢了。</p><p>然后，开始码代码。结果一上来就遇到之前在lc讨论区看到的题，具体链接在<a href="https://leetcode.com/discuss/interview-question/236898/google-phone-interview/237669" target="_blank" rel="noopener">这里</a>：</p><blockquote><p>Given a complete(virtual) binary tree, return true/false if the given target node exists in the tree or not.<br>Here, the “virtual” means the tree nodes are numbered assuming the tree is a complete binary tree.</p><p>For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;                 <span class="number">1</span></span><br><span class="line">&gt;     /        \ </span><br><span class="line">&gt;  <span class="number">2</span>              <span class="number">3</span></span><br><span class="line">&gt;        /   \           /  \ </span><br><span class="line">&gt;      <span class="number">4</span>   (<span class="number">5</span>)nil      <span class="number">6</span>  (<span class="number">7</span>)nil</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="comment">//function signature</span></span><br><span class="line">&gt;    <span class="comment">// bool doesNodeExist(root *TreeNode, target int)</span></span><br><span class="line">&gt;    doesNodeExist(root, <span class="number">4</span>) -&gt; <span class="keyword">true</span></span><br><span class="line">&gt;    doesNodeExist(root, 7) -&gt; false, Given the node on #7 is a nil node.</span><br><span class="line">&gt;    <span class="comment">//Think of a better solution.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这题，我之前就想到一个简单的做法，采用的是将数字二进制表示后，利用0和1定位，每次排除一半的搜索空间，总的时间效率是$O(log(n))$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doesNodeExist</span><span class="params">(TreeNode root, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">char</span>[] binary = Integer.toBinaryString(id).toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; binary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary[i] == <span class="string">'0'</span>) root = root.left;</span><br><span class="line">        <span class="keyword">else</span> root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写的差不多了，然而还是有点bug（我在之前没有练好白板orz，估计就是跪在这里）</p><p>然后修修补补，花了不少时间。之后他提出follow up（其实应该是另一个问题）：</p><blockquote><p>Given a complete(virtual) binary tree, return the number of nodes in the tree.</p></blockquote><p>这个首先当然是给出trivial做法，时间复杂度$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想了一会，想到结合第一题的思路：使用二分的方法，用第一题的函数确认某个结点是否存在于这个树上，然后不断二分搜索空间，时间复杂度为$O(log^2(n))$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="number">1</span>;</span><br><span class="line">    TreeNode tmp = root;</span><br><span class="line">    <span class="keyword">while</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = tmp.right;</span><br><span class="line">        hi = (hi &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hi = (hi &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (exist(root, mi))</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exist(root, lo) ? lo : lo - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这个思路真的是，完美啊！！！但是写的过程还是出了一点bug……最后还是运算符陷阱，java的位运算优先级问题太坑。</p><p>然后写完，时间也差不多了，就这样不明不白地结束了。</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>二面前又刷了一会题，还在一亩三分地看了一些面经，结果看的题<strong>完全没用</strong>，呵呵</p><p>二面面试官给人不善言辞的木讷感觉，我也和第一次不一样，自我介绍的时候说了一下自己的项目。</p><p>对面：有这么多项目经历啊……</p><p>我：嗯嗯（其实心里一脸懵逼）</p><p>然后，话不多说开始做题。</p><blockquote><p>Split an array such that the sum of each split &gt;= target.</p><p>The array consists of only integers in [0, 9].</p><p>Write a function to check whether the array could be split into k parts.</p><p>boolean canSplit(int[] nums, int k, int target)</p></blockquote><p>这题开始的时候他没讲清楚，让我以为是随意的切分，想了半天没话可说，正要和他求个提示，结果他看不下去让我先尝试一下比如<code>nums = [1,2,3,3,2,4,4], k = 3, x = 5</code></p><p>然后贪心地切下去，切成：<code>[1, 2, 3/ 3, 2/ 4, 4]</code>，能够切分三份，所以返回<code>true</code></p><p>好嘛，你直接说连续的切分不就好了。我就说我之前也问了这个问题，然后他没讲清楚。</p><p>这就开始写代码，时间复杂度$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canSplit</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k || x &lt; <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> currSum = <span class="number">0</span>, curr = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; n; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currSum &gt;= x) &#123;</span><br><span class="line">            curr += <span class="number">1</span>;</span><br><span class="line">            currSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currSum += a[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currSum &gt;= x)</span><br><span class="line">        curr++;</span><br><span class="line">    <span class="keyword">return</span> curr &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次我滔滔不绝地讲了这一步做什么，那一步做什么，遇到全0的case等等怎么处理。</p><p>对方说ok，没有问题，就是把那个<code>currSum += a[index]</code>放在前面会比较好，避免循环外面再判断一次，代码更简洁。我说嗯嗯，确实如此。</p><p>接着是follow up：</p><blockquote><p>Now given the array and k, return what’s the maximum target.</p></blockquote><p>这里理解题目就比较麻烦，因为这个maximum其实是某一个切分中，每一份的和的最小值；但是又是不同切分中的最大值。</p><p>我想起以前周赛的一个题，给定天数要求和物品列表，每天载货一次，问最小的单次载货量是多少（题目在<a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">这里</a>）——其实这两题比较像，稍加分析就可以看出：</p><ul><li>在这里是从<code>0</code>开始找到<code>sum</code>，前面都是可以的，到某一个值开始不能拆分成k份；</li><li>在上面那个载货题，从<code>0</code>开始找到<code>sum</code>，前面的<code>capacity</code>不能在<code>k</code>天载完，在某一个值开始可以载完。</li></ul><p>联想到这一题用的是二分，我就打算在这里也用二分，使用上一个题目的<code>canSplit</code>进行判断。</p><p>我一提出二分，对方就大为赞赏，这让我有些振奋，于是确定地提出想法，然后开始码，时间复杂度$O(nlogn)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSplit</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = a.length;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; k || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// indicating invalid error</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : a)</span><br><span class="line">        sum += num;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = sum;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (canSplit(a, k, mi))</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canSplit(a, k, lo) ? lo : lo - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完一看，和一面的思路也太像了吧！不过我没有说，检查了很多<code>case</code>之后对方说很好，代码没有问题，而且风格也不错。</p><p>接下来提出进一步的follow up：</p><blockquote><p>What if the array contains minus numbers?</p></blockquote><p>这里我一开始没明白，负数会有影响吗？</p><p>后来才发现，对这种例子，就会对<code>canSplit</code>函数产生影响：<code>nums = [1, 2, 3, -1, 4, 1], target = 5</code></p><p>在这里，如果我们在<code>3</code>后面分割，那么后面就不能组成一个split，只能分成1份；但是如果我们在<code>-1</code>后面切分，那么就可以分成2份。然而我并没有想出来……</p><p>看到我的窘况，他说没关系，提示我用dp，并且贴心地换了一个follow up：</p><blockquote><p>What if the maxSplit function is called many times on the same array?</p></blockquote><p>也就是如何优化的问题。我这个时候脑子是糊的，但是盲猜了一个方法（套路啊）：前缀和数组。</p><p>这个概念一提出来，对方就很满意，接下来补全了思路：在前缀和数组上作二分找到下一个可切分的位置，将<code>canSplit</code>原来遍历数组的过程转化为二分，提高效率。</p><p>这样做之后，总时间效率就是$O(log^2(n))$，和一面的解法结构也很像——只能说我运气实在太好了吧。</p><p>然而这样还是没有利用好机会……orz</p><p>经过这样两次面试，我只能说，二分天下无敌！</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;3月29更新：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Your Current Stage:&lt;/strong&gt;  Pending. Unfortunately, your current interview result is not strong enough to proceed to next step, we will try to strive opportunity for you. If there is any update about proceed or reject, I’ll definitely let you know.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天发邮件催了一下hr，对面表示面试成绩不够好被挂着，然而也没有直接刷……学长说其实基本就是算凉了，我也不抱希望。&lt;/p&gt;
&lt;p&gt;总体来说二面发挥较好，一面比较失败。等有空再补一下这两次面试的经历。&lt;/p&gt;
&lt;p&gt;还是希望有加面的机会啊……毕竟准备了两个月刷leetcode（虽然还是很菜）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://yoursite.com/categories/interview/"/>
    
    
      <category term="intern" scheme="http://yoursite.com/tags/intern/"/>
    
      <category term="google" scheme="http://yoursite.com/tags/google/"/>
    
  </entry>
  
  <entry>
    <title>重置系统和ssh连接</title>
    <link href="http://yoursite.com/2019/03/28/%E9%87%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%92%8Cssh%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/03/28/重置系统和ssh连接/</id>
    <published>2019-03-27T17:51:45.000Z</published>
    <updated>2019-03-27T20:08:09.146Z</updated>
    
    <content type="html"><![CDATA[<p>之前不小心更新了Ubuntu18.0，结果没法ssh连接了。。。</p><p>无奈之下重置了系统，知乎查了一下Ubuntu和其他Linux系统，感觉相对于服务器来说Debian更加稳定些，Ubuntu太倒腾了。重置完了之后，再ssh连接，咦？为啥还是不能连。。。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:2R1nMbHLVDbkj8Q564B1ZwsBkDMm92bJtL4hhb5FSr4.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /Users/Aki/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /Users/Aki/.ssh/known_hosts:2</span><br><span class="line">ECDSA host key for 120.79.161.245 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><p>这应该是我自己电脑对对面系统做了检测，发现ecdsa的验证码不一样了（因为重置了系统啊，感觉不安全就不让我连接了（这个@@@……是我乔鲁诺哒！</p><p>于是谷歌了一下，发现可以通过这个指令移除：<code>ssh-keygen -R [ip]</code></p><p>系统回复：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Host 120.79.161.245 found: line 2</span><br><span class="line">/Users/Aki/.ssh/known_hosts updated.</span><br><span class="line">Original contents retained as /Users/Aki/.ssh/known_hosts.old</span><br></pre></td></tr></table></figure><p>ok了。现在可以重新连接。</p><p>重新连接后会询问你是否信任，yes之后就会重新将域名加入列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前不小心更新了Ubuntu18.0，结果没法ssh连接了。。。&lt;/p&gt;
&lt;p&gt;无奈之下重置了系统，知乎查了一下Ubuntu和其他Linux系统，感觉相对于服务器来说Debian更加稳定些，Ubuntu太倒腾了。重置完了之后，再ssh连接，咦？为啥还是不能连。。。&lt;/p&gt;
    
    </summary>
    
      <category term="back end" scheme="http://yoursite.com/categories/back-end/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>收报名表过程出现的bug以及解决方案</title>
    <link href="http://yoursite.com/2019/03/28/%E6%94%B6%E6%8A%A5%E5%90%8D%E8%A1%A8%E8%BF%87%E7%A8%8B%E5%87%BA%E7%8E%B0%E7%9A%84bug%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/28/收报名表过程出现的bug以及解决方案/</id>
    <published>2019-03-27T17:48:30.000Z</published>
    <updated>2019-03-27T18:04:06.977Z</updated>
    
    <content type="html"><![CDATA[<ul><li>校友文件名太长的问题</li><li>文件太大的问题（60m出错，姓名未填写错误）</li><li>校友文件名过长（因命名规则：账号+下划线+账号的md5值）</li><li>文件传不了，未知原因</li><li>文件无法覆盖，未知原因</li></ul><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>无法覆盖<ul><li>数据库里已经有相应文件名，只需要在文件目录<code>/var/www/File/applyfile</code>中替换文件即可。</li></ul></li><li>无法上传<ul><li>数据库中修改对应学号的<code>profile</code>属性为文件名。</li><li>在文件目录中加入文件。 </li></ul></li><li>备注：文件名默认为<code>账户名+下划线+账户名的哈希值</code>，其中账户名可能是学号（本科生）、邮箱（研究生、校友）</li></ul><h3 id="mysql远程连接"><a href="#mysql远程连接" class="headerlink" title="mysql远程连接"></a>mysql远程连接</h3><p>直接在终端建立ssh和mysql连接不安全，而且服务器不支持中文输入，有时候操作不便。</p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><ul><li><code>*. *</code>：表示所有数据库（第一个 <em>）和表（第二个 </em>）。</li><li><code>root</code>：表示允许访问时登陆用的用户名。</li><li><code>%</code>：表示允许来自任何地址的访问。如果要指定一个ip，那么把%换成相应ip。</li><li><code>password</code>：表示设定密码。</li><li><code>flush privileges</code>：表示立即刷新使权限生效。</li></ul><p>这一步之后可以在表中查看结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use mysql</span><br><span class="line">&gt; select * from user;</span><br><span class="line"><span class="comment">-- 可以看到密码是经过md5加密之后的值。</span></span><br></pre></td></tr></table></figure><h4 id="修改cnf文件"><a href="#修改cnf文件" class="headerlink" title="修改cnf文件"></a>修改cnf文件</h4><ul><li>mysql的配置文件在目录<code>/etc/mysql/</code>下，需要编辑其开放的端口。</li><li>将<code>bind-address = 127.0.0.1</code>注释掉，因为它的意思是默认本地端口访问。</li></ul><h4 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h4><p><code>service mysql restart</code></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul><li>打开mysqlworkbench，建立新的连接，输入用户名和密码、服务器ip。端口号默认3306即可。</li><li>进行连接之后就可以远程操作了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;校友文件名太长的问题&lt;/li&gt;
&lt;li&gt;文件太大的问题（60m出错，姓名未填写错误）&lt;/li&gt;
&lt;li&gt;校友文件名过长（因命名规则：账号+下划线+账号的md5值）&lt;/li&gt;
&lt;li&gt;文件传不了，未知原因&lt;/li&gt;
&lt;li&gt;文件无法覆盖，未知原因&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="back end" scheme="http://yoursite.com/categories/back-end/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>27.Remove Element</title>
    <link href="http://yoursite.com/2019/03/28/27-Remove-Element/"/>
    <id>http://yoursite.com/2019/03/28/27-Remove-Element/</id>
    <published>2019-03-27T17:31:06.000Z</published>
    <updated>2019-03-27T18:11:45.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, with the first two elements of nums being <span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">It doesn<span class="string">'t matter what you leave beyond the returned length.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">5</span>, with the first five elements of nums containing <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, and <span class="number">4</span>.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn<span class="string">'t matter what values are set beyond the returned length.</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="双指针，快慢操作"><a href="#双指针，快慢操作" class="headerlink" title="双指针，快慢操作"></a>双指针，快慢操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; fast &lt; nums.length; fast++)</span><br><span class="line">      <span class="keyword">if</span> (nums[fast] != val) nums[slow++] = nums[fast];</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h4 id="双指针——改进"><a href="#双指针——改进" class="headerlink" title="双指针——改进"></a>双指针——改进</h4><ul><li>在val元素较少的时候，为了避免过多的移动，采用交换机制；</li><li>这里的交换十分巧妙：将末尾的数替换当前的i，同时下一轮又会检查i位置的数；而n也会随交换缩小。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">          n--;</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array &lt;em&gt;nums&lt;/em&gt; and a value &lt;em&gt;val&lt;/em&gt;, remove all instances of that value &lt;a href=&quot;https://en.wikipedia.org/wiki/In-place_algorithm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;in-place&lt;/strong&gt;&lt;/a&gt; and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this by &lt;strong&gt;modifying the input array in-place&lt;/strong&gt; with O(1) extra memory.&lt;/p&gt;
&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
      <category term="two pointers" scheme="http://yoursite.com/tags/two-pointers/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>26.Remove Duplicates from Sorted Array</title>
    <link href="http://yoursite.com/2019/03/28/26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://yoursite.com/2019/03/28/26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2019-03-27T17:28:12.000Z</published>
    <updated>2019-03-27T18:11:35.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, with the first two elements of nums being <span class="number">1</span> and <span class="number">2</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="string">'t matter what you leave beyond the returned length.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">5</span>, with the first five elements of nums being modified to <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, and <span class="number">4</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="string">'t matter what values are set beyond the returned length.</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="双指针，快慢操作。"><a href="#双指针，快慢操作。" class="headerlink" title="双指针，快慢操作。"></a>双指针，快慢操作。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; fast &lt; nums.length; fast++)</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) nums[++slow] = nums[fast];</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a sorted array &lt;em&gt;nums&lt;/em&gt;, remove the duplicates &lt;a href=&quot;https://en.wikipedia.org/wiki/In-place_algorithm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;in-place&lt;/strong&gt;&lt;/a&gt; such that each element appear only &lt;em&gt;once&lt;/em&gt; and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this by &lt;strong&gt;modifying the input array in-place&lt;/strong&gt; with O(1) extra memory.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
      <category term="two pointers" scheme="http://yoursite.com/tags/two-pointers/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器部署：Flask + gunicorn + nginx</title>
    <link href="http://yoursite.com/2019/03/28/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%EF%BC%9AFlask-gunicorn-nginx/"/>
    <id>http://yoursite.com/2019/03/28/Linux服务器部署：Flask-gunicorn-nginx/</id>
    <published>2019-03-27T16:17:46.000Z</published>
    <updated>2019-03-27T18:00:03.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器参数"><a href="#服务器参数" class="headerlink" title="服务器参数"></a>服务器参数</h3><ul><li>服务器ip：120.79.161.245（阿里云轻量级服务器，学生机）</li><li>阿里管理控制台：<a href="https://swas.console.aliyun.com/" target="_blank" rel="noopener">https://swas.console.aliyun.com/</a></li><li>os：Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-93-generic x86_64)</li></ul><a id="more"></a><h3 id="连接脚本："><a href="#连接脚本：" class="headerlink" title="连接脚本："></a>连接脚本：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">spawn ssh root@120.79.161.245</span><br><span class="line">expect "*password*" </span><br><span class="line">send "*****"</span><br><span class="line">expect "Welcome*"</span><br><span class="line">send "cd /data/www/\r"</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">sudo apt-get install python3.6</span><br><span class="line">python3 -V  # --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 导出自己电脑上安装的库</span><br><span class="line">pip3 freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 把requirements.txt拷贝到服务器上</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照库列表依次安装库</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><ul><li>这个应该不用多说了吧。指定FLASK的app入口，之后run就可以了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FLASK_APP=war.py</span><br><span class="line">flask run</span><br><span class="line"><span class="meta">#</span> 在war项目下目录结构是这样的：</span><br><span class="line">.</span><br><span class="line">|____app</span><br><span class="line">| |______init__.py</span><br><span class="line">| |______pycache__</span><br><span class="line">| | |____*.pyc</span><br><span class="line">| |____templates</span><br><span class="line">| | |____*.html</span><br><span class="line">| |____routes.py</span><br><span class="line">|______pycache__</span><br><span class="line">| |____*.pyc</span><br><span class="line">|____war.py</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li><code>nginx</code>配置文件：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/nginx./conf</span><br><span class="line"><span class="meta">#</span> 在http的大括号内加入如下内容：</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;  # 监听80号端口（默认访问端口）</span><br><span class="line">server_name _;  # 自身ip，下划线代替；和端口号组成外网监听地址</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:8080;  # 转接到本机地址和端口，挑一个没有被占用的端口</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>gunicorn</code>操作指令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nohup gunicorn -w 1 -b 127.0.0.1:8080 main:app -D</span><br><span class="line"><span class="meta">#</span> nohup表示不输出任何信息，并将log存到当前目录下nohup.out文件；</span><br><span class="line"><span class="meta">#</span> -w指定开启的进程数量，一般推荐：【核数】 * 2 + 1，全写是--workers=1；</span><br><span class="line"><span class="meta">#</span> -b指定转到本机的接口，必须和nginx配置文件的内容一致；</span><br><span class="line"><span class="meta">#</span> 127.0.0.1即localhost，本地端口；</span><br><span class="line"><span class="meta">#</span> main:app指定gunicorn要代理的app入口，表示main.py里面的app；</span><br><span class="line"><span class="meta">#</span> -D表示daemon，守护进程，也就是后台运行</span><br></pre></td></tr></table></figure><ul><li>常用指令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进程相关</span><br><span class="line">kill -s 9 [pid]</span><br><span class="line">ps aux# 查看所有进程</span><br><span class="line">grep [string]  # 查看所有包含[string]的文件</span><br><span class="line">ps aux | grep nginx  # 管道，将显示nginx相关进程信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 文件相关</span><br><span class="line">tree  # linux自带指令</span><br><span class="line"><span class="meta">  #</span> BTW，macOS如果想优雅地使用tree，需要如下操作：</span><br><span class="line"><span class="meta">  #</span> vi ～/.bash_profile  ## 在个人目录下创建/更改配置文件</span><br><span class="line"><span class="meta">  #</span> i  ## 插入模式</span><br><span class="line"><span class="meta">  #</span> alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"  ## 设置同义词组</span><br><span class="line"><span class="meta">  #</span> wq  ## 退出编辑</span><br><span class="line"><span class="meta">  #</span> source .bash_profile  ## 重新加载配置文件</span><br><span class="line">  </span><br><span class="line">cat [filename]</span><br><span class="line">vi [filename]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> nginx相关</span><br><span class="line">/etc/init.d/nginx start</span><br><span class="line">/etc/init.d/nginx stop</span><br><span class="line">/etc/init.d/nginx restart</span><br><span class="line"><span class="meta">#</span> 或者也可以 service nginx start.stop.restart</span><br><span class="line"><span class="meta">#</span> 再或者可以 nginx -s start.stop.restart</span><br><span class="line">vi /etc/nginx/nginx.conf  # 也可以选择 /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure><ul><li><p>关于配置文件</p><ul><li>在配置nginx的时候，网上的资料告诉我配置文件位于<code>/etc/nginx/sites-available/default</code>，我改了半天却并无卯月……然后在zh的帮助下查看了配置文件的路径，我的路径不在参考范围内。</li><li>这个指令既可以测试配置文件的有效性，也可以看到当前运行的配置文件的位置：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx -t</span><br><span class="line"></span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line"><span class="meta">#</span> 于是我们看到/etc/nginx/nginx.conf就是配置文件（这应该是默认的配置文件）</span><br></pre></td></tr></table></figure><ul><li>接着，在这个nginx.conf里面还有一段文字表明nginx会参考的配置文件路径，如果不修改上面第一个文件，修改下面几个路径下的文件也是可以的：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>#</span><br><span class="line"><span class="meta">#</span> Virtual Host Configs</span><br><span class="line"><span class="meta">#</span>#</span><br><span class="line">  </span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure></li><li><p>记一次bug</p><ul><li>10月6日晚，这个ip发生了一次神秘的bug：刷新index页面的时候，游戏轮数时而显示第一轮，时而显示第二轮，但是总是和文件game.txt里面不一致。</li><li>调整了一晚上都没有找到问题的核心，终于在一次调试中偶然发现-w改成1之后就不会出错（后来知道不是这个原因），因此提出一个假说：是不是多个gunicorn进程引发的混乱？</li><li>可惜好景不长，第二天重新使用workers=1的参数测试的时候，发现问题依然存在。最终查看系统所有进程突然发现，关于gunicorn的进程数（每个的workers都是1）出现好几个，分别是不同的时间段开启的……等等，我好像明白了什么。</li><li>最终真相大白：是因为不同时间开启的gunicorn进程未能有效关闭（每一次我都是重启nginx再重新输入gunicorn指令），从而前几次的gunicorn维护的页面和这一次的页面产生了冲突……导致后来的每一次测试都是在几个不同时段的gunicorn进程中辗转，时而进入这个进程时而进入那一个……</li><li>至于昨晚的结果，则应该是因为那一次尝试恰好伴随着服务器的重启的缘故。</li><li>这一次的<strong>教训</strong>：以后，每次结束测试都要把所有gunicorn的进程关闭。nginx也不例外。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;服务器参数&quot;&gt;&lt;a href=&quot;#服务器参数&quot; class=&quot;headerlink&quot; title=&quot;服务器参数&quot;&gt;&lt;/a&gt;服务器参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;服务器ip：120.79.161.245（阿里云轻量级服务器，学生机）&lt;/li&gt;
&lt;li&gt;阿里管理控制台：&lt;a href=&quot;https://swas.console.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://swas.console.aliyun.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;os：Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-93-generic x86_64)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="back end" scheme="http://yoursite.com/categories/back-end/"/>
    
    
      <category term="gunicorn" scheme="http://yoursite.com/tags/gunicorn/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>25.Reverse Nodes in k-Group</title>
    <link href="http://yoursite.com/2019/03/27/25-Reverse-Nodes-in-k-Group/"/>
    <id>http://yoursite.com/2019/03/27/25-Reverse-Nodes-in-k-Group/</id>
    <published>2019-03-27T14:26:23.000Z</published>
    <updated>2019-03-27T18:11:26.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p><a id="more"></a><p><strong>Example:</strong></p><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p><strong>Note:</strong></p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="用k大小的数组存节点，并依次翻转"><a href="#用k大小的数组存节点，并依次翻转" class="headerlink" title="用k大小的数组存节点，并依次翻转"></a>用k大小的数组存节点，并依次翻转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode[] group = <span class="keyword">new</span> ListNode[k + <span class="number">2</span>];<span class="comment">// 保存k集团的前一个，k集团，以及k集团的后一个</span></span><br><span class="line">    group[<span class="number">0</span>] = dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k + <span class="number">2</span> &amp;&amp; group[i - <span class="number">1</span>] != <span class="keyword">null</span>; i++)</span><br><span class="line">            group[i] = group[i - <span class="number">1</span>].next;</span><br><span class="line">        <span class="keyword">if</span> (group[i - <span class="number">1</span>] == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        group[<span class="number">0</span>].next = group[k];</span><br><span class="line">        group[<span class="number">1</span>].next = group[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; k + <span class="number">1</span>; j++)</span><br><span class="line">            group[j].next = group[j - <span class="number">1</span>];</span><br><span class="line">        group[<span class="number">0</span>] = group[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(k)​$</li><li>空间复杂度：$O(n)​$</li></ul><h4 id="只使用常数个节点的做法"><a href="#只使用常数个节点的做法" class="headerlink" title="只使用常数个节点的做法"></a>只使用常数个节点的做法</h4><ul><li>问题的关键在于如何反转一个k大小的链表；这里使用的是将每次的第一个插到末尾的做法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k &lt; <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode tail = dummy, prev = dummy, temp;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        count = k;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span> &amp;&amp; tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>)<span class="comment">// 剩下来节点不够k个</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 此时tail指向k集团的最后一个节点</span></span><br><span class="line">        head = prev.next;<span class="comment">// head指向的是k集团的第一个节点，将会是翻转后最后一个节点，</span></span><br><span class="line">      <span class="comment">// 同时也是下一个k集团的前一个节点</span></span><br><span class="line">        <span class="comment">// prev--&gt;temp--&gt;...---&gt;....---&gt;tail--&gt;....</span></span><br><span class="line">        <span class="comment">// Delete @temp and insert to the next position of @tail</span></span><br><span class="line">        <span class="comment">// prev--&gt;...--&gt;...--&gt;tail--&gt;head--&gt;...</span></span><br><span class="line">        <span class="comment">// Assign @temp to the next node of @prev</span></span><br><span class="line">        <span class="comment">// prev--&gt;temp--&gt;...--&gt;tail--&gt;...--&gt;...</span></span><br><span class="line">        <span class="comment">// Keep doing until @tail is the next node of @prev</span></span><br><span class="line">        <span class="keyword">while</span> (prev.next != tail) &#123;</span><br><span class="line">            temp = prev.next;<span class="comment">//Assign</span></span><br><span class="line">            prev.next = temp.next;<span class="comment">//Delete，从左侧删除temp</span></span><br><span class="line">            temp.next = tail.next;</span><br><span class="line">            tail.next = temp;<span class="comment">//Insert，在右侧末尾插入temp</span></span><br><span class="line">        &#125;</span><br><span class="line">        tail = prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)​$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a linked list, reverse the nodes of a linked list &lt;em&gt;k&lt;/em&gt; at a time and return its modified list.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k&lt;/em&gt; is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of &lt;em&gt;k&lt;/em&gt; then left-out nodes in the end should remain as it is.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="linked list" scheme="http://yoursite.com/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>24.Swap Nodes in Pairs</title>
    <link href="http://yoursite.com/2019/03/27/24-Swap-Nodes-in-Pairs/"/>
    <id>http://yoursite.com/2019/03/27/24-Swap-Nodes-in-Pairs/</id>
    <published>2019-03-27T14:22:31.000Z</published>
    <updated>2019-03-27T18:11:14.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p> <a id="more"></a><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, you should <span class="keyword">return</span> the list as <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>.</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="直接做就可以了；小心边界情况"><a href="#直接做就可以了；小心边界情况" class="headerlink" title="直接做就可以了；小心边界情况"></a>直接做就可以了；小心边界情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pre = dummy, first = head;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode tmp = first.next;</span><br><span class="line">        <span class="comment">// 无视没有配对的点</span></span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre.next = tmp;</span><br><span class="line">        first.next = tmp.next;</span><br><span class="line">        tmp.next = first;</span><br><span class="line">        <span class="comment">// 下一对节点</span></span><br><span class="line">        pre = first;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;You may &lt;strong&gt;not&lt;/strong&gt; modify the values in the list’s nodes, only nodes itself may be changed.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
      <category term="linked list" scheme="http://yoursite.com/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>23.Merge k Sorted Lists</title>
    <link href="http://yoursite.com/2019/03/27/23-Merge-k-Sorted-Lists/"/>
    <id>http://yoursite.com/2019/03/27/23-Merge-k-Sorted-Lists/</id>
    <published>2019-03-27T13:55:01.000Z</published>
    <updated>2019-03-27T18:10:55.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><a id="more"></a><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="将全部元素加入list，排序后转回链表"><a href="#将全部元素加入list，排序后转回链表" class="headerlink" title="将全部元素加入list，排序后转回链表"></a>将全部元素加入list，排序后转回链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ListNode curr : lists) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp.add(curr.val);</span><br><span class="line">          curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  Collections.sort(tmp);</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr = dummy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : tmp) &#123;</span><br><span class="line">      curr.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlog(n))$，其中n是总节点数</li><li>空间复杂度：$O(n)$</li></ul><h4 id="使用最小堆（优先队列）"><a href="#使用最小堆（优先队列）" class="headerlink" title="使用最小堆（优先队列）"></a>使用最小堆（优先队列）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; nodeHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr = dummy;</span><br><span class="line">    <span class="keyword">for</span> (ListNode head: lists)</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">          nodeHeap.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">        curr.next = nodeHeap.poll();</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (curr.next != <span class="keyword">null</span>)</span><br><span class="line">          nodeHeap.add(curr.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogk)$</li><li>空间复杂度：$O(n+k)​$</li></ul><h4 id="一个接一个合并"><a href="#一个接一个合并" class="headerlink" title="一个接一个合并"></a>一个接一个合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">  ListNode res;</span><br><span class="line">  <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  res = lists[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.length; i++)</span><br><span class="line">      res = merge(res, lists[i]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code from 21.Merge two lists</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode l = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), tmp = l;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            tmp.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(kn)​$</li><li>空间复杂度：$O(n)$</li></ul><h4 id="分治法，两两合并，然后再合并……"><a href="#分治法，两两合并，然后再合并……" class="headerlink" title="分治法，两两合并，然后再合并……"></a>分治法，两两合并，然后再合并……</h4><ul><li><strong>这是实践效果最快的！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> helper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">helper</span><span class="params">(ListNode list[], <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (from == to)</span><br><span class="line">      <span class="keyword">return</span> list[from];</span><br><span class="line">  <span class="keyword">if</span> (from == to - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> merge(list[from], list[to]);</span><br><span class="line">  <span class="keyword">int</span> mid = from + (to - from) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> merge(helper(list, from, mid), helper(list, mid + <span class="number">1</span>, to));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code from 21.Merge two lists</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode l = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), tmp = l;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            tmp.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogk)​$</li><li>空间复杂度：$O(n+log(k))$，其中$log(k)$为递归的栈深度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Merge &lt;em&gt;k&lt;/em&gt; sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="divide and conquer" scheme="http://yoursite.com/tags/divide-and-conquer/"/>
    
      <category term="linked list" scheme="http://yoursite.com/tags/linked-list/"/>
    
      <category term="priority queue" scheme="http://yoursite.com/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>22.Generate Parentheses</title>
    <link href="http://yoursite.com/2019/03/27/22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2019/03/27/22-Generate-Parentheses/</id>
    <published>2019-03-27T11:27:13.000Z</published>
    <updated>2019-03-27T18:10:32.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><a id="more"></a><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="递归-回溯，记录开闭括号数量保持平衡"><a href="#递归-回溯，记录开闭括号数量保持平衡" class="headerlink" title="递归+回溯，记录开闭括号数量保持平衡"></a>递归+回溯，记录开闭括号数量保持平衡</h4><ul><li>使用char数组，节约空间、提高效率。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bound;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == bound &amp;&amp; right == bound) &#123;</span><br><span class="line">        res.add(String.valueOf(word));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; bound) &#123;</span><br><span class="line">        word[left + right] = <span class="string">'('</span>;</span><br><span class="line">        helper(left + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; bound &amp;&amp; right &lt; left) &#123;</span><br><span class="line">        word[left + right] = <span class="string">')'</span>;</span><br><span class="line">        helper(left, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    bound = n;</span><br><span class="line">    word = <span class="keyword">new</span> <span class="keyword">char</span>[n + n];</span><br><span class="line">    helper(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，这个论证比较复杂，详见<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0" target="_blank" rel="noopener">卡塔兰数</a></li><li>空间复杂度：$O(\dfrac{4^n}{\sqrt{n}})​$</li></ul><h4 id="递归的风骚写法！"><a href="#递归的风骚写法！" class="headerlink" title="递归的风骚写法！"></a>递归的风骚写法！</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">            <span class="keyword">for</span> (String left: generateParenthesis(c))</span><br><span class="line">                <span class="keyword">for</span> (String right: generateParenthesis(n-<span class="number">1</span>-c))</span><br><span class="line">                    ans.add(<span class="string">"("</span> + left + <span class="string">")"</span> + right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$</li><li>空间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given &lt;em&gt;n&lt;/em&gt; pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
      <category term="permutation" scheme="http://yoursite.com/tags/permutation/"/>
    
      <category term="backtracking" scheme="http://yoursite.com/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>21.Merge Two Sorted Lists</title>
    <link href="http://yoursite.com/2019/03/27/21-Merge-Two-Sorted-Lists/"/>
    <id>http://yoursite.com/2019/03/27/21-Merge-Two-Sorted-Lists/</id>
    <published>2019-03-27T11:22:13.000Z</published>
    <updated>2019-03-27T18:10:19.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><a id="more"></a><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="归并常规做法。"><a href="#归并常规做法。" class="headerlink" title="归并常规做法。"></a>归并常规做法。</h4><ul><li>这里如果不能指向原来的元素就不能这样写，需要重新创造node。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n1 + n2)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="two pointers" scheme="http://yoursite.com/tags/two-pointers/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
      <category term="linked list" scheme="http://yoursite.com/tags/linked-list/"/>
    
  </entry>
  
</feed>
