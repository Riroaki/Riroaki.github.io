{"meta":{"title":"Riroaki","subtitle":"Riroaki's home","description":"我还要去完成应做之事。","author":"Riroaki","url":"http://riroaki.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-24T12:33:57.000Z","updated":"2019-04-09T12:06:40.449Z","comments":true,"path":"about/index.html","permalink":"http://riroaki.github.io/about/index.html","excerpt":"","text":"这里是Riroaki的个人小站。 用来标记自己来时的路。"},{"title":"categories","date":"2019-03-24T12:31:34.000Z","updated":"2019-04-09T12:04:49.546Z","comments":true,"path":"categories/index.html","permalink":"http://riroaki.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-24T12:26:06.000Z","updated":"2019-04-09T12:05:24.696Z","comments":true,"path":"tags/index.html","permalink":"http://riroaki.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-28T12:27:37.124Z","updated":"2019-02-24T16:30:40.702Z","comments":true,"path":"voi/README.html","permalink":"http://riroaki.github.io/voi/README.html","excerpt":"","text":"VOI A simple game still under construction. Inspired by VOI on iOS."},{"title":"","date":"2019-03-28T12:22:57.198Z","updated":"2019-02-24T09:49:10.145Z","comments":true,"path":"voi/about.html","permalink":"http://riroaki.github.io/voi/about.html","excerpt":"","text":"VOI L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":600,\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":true,\"scale\":0.5},\"log\":false});"},{"title":"","date":"2019-03-28T12:22:57.197Z","updated":"2019-02-24T09:48:57.432Z","comments":true,"path":"voi/contact.html","permalink":"http://riroaki.github.io/voi/contact.html","excerpt":"","text":"VOI L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":600,\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":true,\"scale\":0.5},\"log\":false});"},{"title":"","date":"2019-03-28T15:25:31.653Z","updated":"2019-02-24T16:05:07.585Z","comments":true,"path":"voi/index.html","permalink":"http://riroaki.github.io/voi/index.html","excerpt":"","text":"voi 当前浏览器不支持canvas，请更换浏览器后再试 VOI VOI Play Contact About &copy; Riroaki 2019 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":600,\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":true,\"scale\":0.5},\"log\":false});"},{"title":"","date":"2019-03-28T12:29:22.806Z","updated":"2019-02-24T13:07:24.493Z","comments":true,"path":"voi/play.html","permalink":"http://riroaki.github.io/voi/play.html","excerpt":"","text":"VOI 当前浏览器不支持canvas，请更换浏览器后再试 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":600,\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":true,\"scale\":0.5},\"log\":false});"},{"title":"","date":"2019-03-28T12:22:57.192Z","updated":"2019-02-24T10:15:45.670Z","comments":true,"path":"voi/css/default.css","permalink":"http://riroaki.github.io/voi/css/default.css","excerpt":"","text":"html, body { height: 100%; width: 100%; overflow: hidden; background-color: black; font-family: 'Josefin Slab', 'Century Gothic', 'TeXGyreAdventor', \"STHeiti\", sans-serif; } #head { margin: 5% auto; display: block; } #menu { display: none; } a { text-decoration: none; } a:hover { text-decoration: none; } .blurMenu { padding: 0; margin: 0 0 10px 0; position: relative; } .blurMenu li a { font-size: 60px; white-space: nowrap; color: transparent; display: block; text-transform: uppercase; text-align: center; text-shadow: 0 0 6px #fff; letter-spacing: 1px; -webkit-transform: scale(0.75); transform: scale(0.75); transition: all 0.3s linear; margin: 3%; } .blurMenu:hover li a { text-shadow: 0 0 15px #fff; } .blurMenu li a:hover { text-shadow: 0 0 1px #fff; -webkit-transform: scale(1); transform: scale(1); } #foot { color: white; position: fixed; text-align: center; left: 0; right: 0; bottom: 20px; margin: auto; }"},{"title":"","date":"2019-03-28T12:22:57.194Z","updated":"2019-02-24T16:42:47.819Z","comments":true,"path":"voi/css/svg.css","permalink":"http://riroaki.github.io/voi/css/svg.css","excerpt":"","text":"/* VOI三个字需要的css： */ .text--transparent { fill: transparent; } .anim-shape { -webkit-transform-origin: 0 150px; transform-origin: 0 150px; -webkit-transform: scale(0, 1) translate(0, 0); transform: scale(0, 1) translate(0, 0); -webkit-animation: moving-panel 3s infinite alternate; animation: moving-panel 3s infinite alternate; } .colortext .anim-shape:nth-child(1) { fill: black; } .colortext .anim-shape:nth-child(2) { /*fill: #166973;*/ fill: gray; } .colortext .anim-shape:nth-child(3) { /*fill: #65bfa6;*/ fill: white; } .colortext .anim-shape:nth-child(4) { /*fill: #f2cd5c;*/ fill: gray; } .colortext .anim-shape:nth-child(5) { /*fill: #f26444;*/ fill: black; } .shadow { -webkit-transform: translate(10px, 10px); transform: translate(10px, 10px); } .anim-shape--shadow { fill: #000; fill-opacity: 0.2; } @-webkit-keyframes moving-panel { 100% { -webkit-transform: scale(1, 1) translate(20px, 0); transform: scale(1, 1) translate(20px, 0); } } @keyframes moving-panel { 100% { -webkit-transform: scale(1, 1) translate(20px, 0); transform: scale(1, 1) translate(20px, 0); } } /* Other stuff */ .content { font: 800 14.5em/1 'Open Sans', Impact; } svg { width: 100%; margin: -10% auto 100px; display: block; text-transform: uppercase; cursor: pointer; }"},{"title":"","date":"2019-03-28T12:22:57.194Z","updated":"2019-02-24T13:41:52.488Z","comments":true,"path":"voi/css/play.css","permalink":"http://riroaki.github.io/voi/css/play.css","excerpt":"","text":"* { margin: 0; padding: 0; } html, body { height: 100%; width: 100%; overflow: hidden; background-color: black;/*这里背景填充黑色，然后画布一开始画上白色，再描黑点，避免开头闪一下造成不连贯的感觉*/ font-family: 'Josefin Slab', 'Century Gothic', 'TeXGyreAdventor', \"STHeiti\", sans-serif; } canvas { display: block; }"},{"title":"","date":"2019-03-28T12:47:47.703Z","updated":"2019-03-28T12:47:47.703Z","comments":true,"path":"voi/js/head.js","permalink":"http://riroaki.github.io/voi/js/head.js","excerpt":"","text":"const canvas = document.getElementById('head'); //存储画布宽高 const H = canvas.height, W = canvas.width; const sqrt3 = Math.sqrt(3); //存储图形 const NUM = 3; const graphs = []; // 所有图形的外接圆半径 const radius = H / 4; // 绘制图形 getVOI(); let oTimer = null; clearInterval(oTimer); oTimer = setInterval(function () { //更新小球运动状态 updateVOI(); //渲染小球 renderVOI(); }, 20); function getVOI() { let vx = Math.floor(Math.random() * 2 - 4), vy = Math.floor(Math.random() * 2 - 4); if (canvas.getContext) { for (let i = 0; i < NUM; i++) { const tempX = Math.floor(Math.random() * (W - radius) + radius); const tempY = Math.floor(Math.random() * (H - radius) + radius); vx += Math.floor(Math.random() - 2); vy += Math.floor(Math.random() - 2); const ball = { x: tempX, y: tempY, stepX: vx / 3, stepY: vy / 3, halfW: 0 }; graphs.push(ball); } graphs[0].halfW = radius * 2 / sqrt3; graphs[1].halfW = radius; graphs[2].halfW = radius / 2; } } function updateVOI() { for (let i = 0; i < graphs.length; i++) { graphs[i].x += graphs[i].stepX; graphs[i].y += graphs[i].stepY; bumpTest(graphs[i]); } } // 碰撞检测 function bumpTest(ele) { let w = ele.halfW; if (ele.x = W - w) { ele.x = W - w; ele.stepX = -ele.stepX; } if (ele.y = H - radius) { ele.y = H - radius; ele.stepY = -ele.stepY; } } function renderVOI() { //重置画布高度，达到清空画布的效果 canvas.height = H; const color = 'rgb(' + 255 + ',' + 255 + ',' + 255 + ')'; if (canvas.getContext) { const ctx = canvas.getContext('2d'); // 画 \"V\" ctx.beginPath(); let x0 = graphs[0].x - radius * 2 / sqrt3, y0 = graphs[0].y - radius; ctx.moveTo(x0, y0); ctx.lineTo(x0 + radius * 4 / sqrt3, y0); ctx.lineTo(graphs[0].x, y0 + radius * 2); ctx.lineTo(x0, y0); ctx.fillStyle = color; ctx.globalCompositeOperation = 'xor'; ctx.closePath(); ctx.fill(); // 画 \"O\" ctx.beginPath(); ctx.arc(graphs[1].x, graphs[1].y, radius, 0, 2 * Math.PI); ctx.fillStyle = color; ctx.globalCompositeOperation = 'xor'; ctx.closePath(); ctx.fill(); // 画 \"I\" ctx.beginPath(); let x = graphs[2].x - radius / 2, y = graphs[2].y - radius; ctx.moveTo(x, y); ctx.lineTo(x + radius, y); ctx.lineTo(x + radius, y + radius * 2); ctx.lineTo(x, y + radius * 2); ctx.lineTo(x, y); ctx.fillStyle = color; ctx.globalCompositeOperation = 'xor'; ctx.closePath(); ctx.fill(); } }"},{"title":"","date":"2019-03-28T12:36:45.864Z","updated":"2019-03-28T12:36:45.864Z","comments":true,"path":"voi/js/transition.js","permalink":"http://riroaki.github.io/voi/js/transition.js","excerpt":"","text":"const canvas = document.getElementById(\"head\"), ctx = canvas.getContext('2d'); const H = window.innerHeight, W = window.innerWidth, R = H / 20, diff = R / 20; let vertices = [], timer = null; for (let i = R / 2; i < W; i += R) { for (let j = R / 2; j < H; j += R) { vertices.push({ x: i, y: j, radius: 2 * R }); } } // console.log(vertices.length); clearInterval(timer); // 开场特效，屏幕黑点遍布，底色为白色 window.onload = function() { let dist = Math.floor(Math.sqrt((W / 2 - R / 2) ** 2 + (H / 2 - R / 2) ** 2)); timer = setInterval(function () { canvas.height = H; canvas.width = W; ctx.rect(0, 0, W, H); ctx.fillStyle = \"white\"; ctx.fill(); let continueDrawing = false; for (let i = 0; i < vertices.length; i++) { let currentDist = Math.floor(Math.sqrt((W / 2 - vertices[i].x) ** 2 + (H / 2 - vertices[i].y) ** 2)); if (dist 0) { ctx.beginPath(); ctx.arc(vertices[i].x, vertices[i].y, vertices[i].radius, 0, 2 * Math.PI); ctx.fillStyle = \"black\"; ctx.closePath(); ctx.fill(); continueDrawing = true; } } if (!continueDrawing) { clearInterval(timer); } dist -= R / 2; }, 20); }"},{"title":"","date":"2019-03-28T12:22:57.177Z","updated":"2019-02-24T16:17:20.183Z","comments":true,"path":"voi/js/index.js","permalink":"http://riroaki.github.io/voi/js/index.js","excerpt":"","text":"// logo文字VOI消失 function hideLogo() { let svg = document.getElementById(\"svg\"), timer = null, alpha = 100; clearInterval(timer); // 让VOI的logo消失 timer = setInterval(function () { if (alpha === 0) { clearInterval(timer); svg.style.display = \"none\"; showMenu(); } else { alpha -= 10; svg.style.opacity = alpha / 100; svg.style.filter = 'alpha(opacity:' + alpha + ')'; } }, 30); } // 菜单出现 function showMenu() { let menu = document.getElementById(\"menu\"), timer = null, alpha = 0; clearInterval(timer); // 让菜单出现 menu.style.display = \"block\"; menu.style.opacity = alpha / 100; timer = setInterval(function () { if (alpha === 100) { clearInterval(timer); } else { alpha += 10; menu.style.opacity = alpha / 100; menu.style.filter = 'alpha(opacity:' + alpha + ')'; } }, 30); } // 设置页面重定向逻辑 /** * @return {boolean} */ function IsPC() { const userAgentInfo = navigator.userAgent, Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; for (let v = 0; v < Agents.length; v++) if (userAgentInfo.indexOf(Agents[v]) > 0) return false; return true; } let isClicked = [0, 0, 0], links = ['play.html', 'contact.html', 'about.html']; function direct(dest) { let id = parseInt(dest); // 如果是电脑，悬浮的时候文字已经放大清晰，只需要点击一次 if (IsPC()) window.location.href = links[id]; else { // 如果是手机操作，那么第一次点击放大，第二次就打开页面 for (let i = 0; i < isClicked.length; i++) { if (id !== i) isClicked[i] = 0; } if (++isClicked[id] === 2) { window.location.href = links[id]; isClicked[id] = 0; } } }"}],"posts":[{"title":"机器学不动了-05：支持向量机","slug":"Machine-Learning-05-Support-Vector-Machine","date":"2019-06-25T04:00:00.000Z","updated":"2019-07-02T16:44:31.425Z","comments":true,"path":"Machine-Learning-05-Support-Vector-Machine/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-05-Support-Vector-Machine/","excerpt":"","text":"本文是”机器学不动了”系列的第五篇文章，内容包含了支持向量机的详细理论和实现。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork与pr。 引子上一篇内容中介绍了逻辑回归的内容，并以此展示了线性分类器最基本的形式。 本文介绍的支持向量机也是一种线性分类器，只不过获得模型的方式有所不同。 作为复习，我们重新回顾一下逻辑回归的分类方式： $y=a^Tx$，在$y&gt;0$的时候被投影到区间$(0.5,1)$，所以分类为正类； 在$y&lt;0$的时候被投影到区间$(0,0.5)$所以分类为负类。 $a$被称为分割向量，或者解向量，而每一个分类向量都对应着一个分类平面，把投影到空间中的所有点$X_i$分为两类。 下图用于解释分类平面与参数$a$（$a=[w,b]$）的关系： 那么，这个向量是唯一的吗？ 答案是，在有限且线性可分的数据集上，一般是存在无数可行的分类面/分类向量的，如下图： 那么很自然的我们就会有一个问题，怎样分类才是最优的呢？ 这个最优的平面，理应是能够帮助我们在测试数据上有最好的分类效果的： 直觉上来看，这个分类面不应该过于靠近某一类点（或者甚至插入了同一类点之间），而是让两类点尽量离分类平面较远。因为距离近表示接近边界，那么这些点是最容易被误分类的，我们希望这样的点越少越好——也就是，希望我们的分类器的分类结果都是极端一点，模棱两可的结果尽量少一些。 换句话说，每一个点到超平面的距离都应当尽量的大，应对新数据理应有好的表现。 而事实上超平面稍微改变，影响的主要是和平面近邻的点，所以我们定义概念： Margin：分类平面到点集的最小距离。 用数学化的语言描述，我们所追求的目标就是找到一个分类面可以最大化margin。 答案已经呼之欲出了，那就是今天的主角——支持向量机（Support Vector Machine）。 支持向量机理论首先复习一下点到平面距离公式： 对平面$C:y=a_0+a_1x_1+a_2x_2+…+a_nx_n$，任意一个点$x=[x_1,x_2,…,x_n]$到平面的距离为： $d=\\frac{|a_0+a_1x_1+a_2x_2+…+a_nx_n|}{\\sqrt{a_0^2+a_1^2+a_2^2+…+a_n^2}}=\\frac{|y(x)|}{||a||_2-a_0^2}$ 因而，我们希望找到的由$a$决定的分类平面应当是： $w,b=\\arg \\max \\min \\frac{|w^Tx+b|}{||w||_2}$ 同时，我们希望它是分类正确的。虽然距离足够大，但是不保证分类正确那不就本末倒置了吗！ 所以在这个表达式中加入分类的信息： $w,b=\\arg \\max \\min \\frac{y_i(w^Tx_i+b)}{||w||_2}$ 这里的$y_i\\in {-1,1}$，表示正类和负类。由此可见SVM也是一种二分类算法。 观察这个表达式，如果分类正确，那么$w^Tx_i+b$和$y_i$应该是同号的，反之是异号。 因而这个表达式是合理的，它同时包含了“分类正确”和“点到平面距离最大”的目标。 变换如果说到此为止，那就太简单了，然而支持向量机这名字还没出来呢！ 接着推呗。 回到上面这个式子：最大化$\\frac{y_i(w^Tx_i+b)}{||w||_2}$，是不是单纯最大化分子&amp;最小化分母就可以了？ 当然不是。因为上下都有$w$这一项。 但是注意到$a$决定了平面之后，等比例地缩放$a$不会改变平面，但是却改变了分子分母的值，对我们的计算带来困扰。我们当然希望控制的变量越少越好，希望分子和分母不要存在关联，这样我们只需要考虑一边就可以。 所以我们令$y_i(w^Tx_i+b)=1$，这样问题就转变为求$\\frac{1}{||w||_2}$的最大值，也就是求$||w||_2$的最小值。 稍微修整表达，问题被改写为： $\\min\\frac{1}{2}||w||_2^2$ $s.t. y_i(w^Tx_i+b)\\ge1$ 平方和系数$\\frac{1}{2}$是为了求导方便和导数形式所确定的，不会对结果有影响。 支持向量说了这么多，支持向量到底是什么？ 稍微抽象化地想一想：我们的平面是被空间中的点“支撑”起来的，因为它们需要保持一定的距离。就像磁铁的两极相斥一样，平面受到了点的斥力而树立起来。 所以，这些点就叫做“支持向量” 而因为我们只考虑最近的点来计算点到平面的距离最小值，所以支持向量指的是靠近平面的那些点。 所以选取点的个数也是一个超参数，它减少了计算量（原本是对每一个点都进行计算）。 软间隔说完了基本的理论部分，接下来要对算法进行批判了。 设想一下，目前的支持向量机算法是建立在“数据线性可分”的基础上，也就是说，所有的点都能够分类在平面两侧。 假如因为标注错误或者别的特殊情况，数据中有那么几个点不小心分错了，跑到平面的另一侧去了呢？ 对这些点，我们的算法缺少一定的容忍性（鲁棒性），会被这些点（如果它们又刚好足够近，会被选择成为支持向量），那么就会被它们带偏——所以说，一颗老鼠屎坏了一锅粥啊。 下面就介绍一个补救措施： 松弛变量在应对近似线性可分的问题的时候，我们需要稍微放松要求，允许支持向量的点到平面的距离稍微近一点。 在公式上我们引入了一个变量，叫做松弛变量（Slack variable）： $min\\frac{1}{2}||w||2^2+C\\Sigma{i=1}^n\\epsilon_i$$ $s.t.y(w^Tx_i+b)\\ge 1-\\epsilon_i,$$ $\\epsilon_i\\ge0$ 这里，$C$是用来控制原目标（最小化$w$）和新目标之间（保证尽量多的margin大于等于1）的权重的， 与这个做法相对的，我们原来的做法就叫做硬间隔（Hard margin）。 代码实现支持向量机的理论还不止这些内容，但是目前掌握的知识足够我们实现一个简易的支持向量机了。 本次实现了简化的SVM算法，用到scipy库的优化函数取最小点来完成二次规划的部分。 代码中已经给出部分注释，如有疑问请在评论区留言。其他详情请见我的repo。 import numpy as np from supervised._base import LinearModel from scipy.optimize import minimize class SVM(LinearModel): \"\"\"Support vector machine model, binary classifier.\"\"\" def __init__(self): super().__init__() def fit(self, x: np.ndarray, label: np.ndarray, **kwargs) -> np.float: # Target and constraint functions def target(w): return w[1:].dot(w[1:]) def get_func(i): return lambda w: w.dot(x_ext[i]) * label[i] - 1 # Target and constraint functions with slack variables def target_slack(w_e): w = w_e[: (p + 1)] eps = w_e[(p + 1):] return 0.5 * w[1:].dot(w[1:]) + c * np.sum(eps) def get_func_slack_w(i): return lambda w_e: w_e[: (p + 1)].dot(x_ext[:, i]) \\ * label[0][i] - 1 + w_e[p + i] def get_func_slack_e(i): return lambda w_e: w_e[p + i] assert np.array_equal(np.unique(label), np.array([-1, 1])) assert x.shape[0] == label.shape[0] n, p = x.shape if self._w is None or self._b is None or self._w.shape[0] != p: # Initialize weights using random values self._init_model(p) # No slack parameters unless explicitly stated slack = False if kwargs is not None: # Update parameters of training self._update_params(kwargs) # Whether to use slack variables if 'slack' in kwargs: assert isinstance(kwargs['slack'], bool) slack = kwargs['slack'] w_ext = np.hstack((self._w, self._b)) x_ext = np.hstack((x, np.ones((n, 1)))) # Find optimum w and b for both condition if not slack: # SVM without slack # Optimize 1/2 w^T * w # s.t. yi * (w^T * xi + b) - 1 >= 0 cons = [{'type': 'ineq', 'fun': get_func(i)} for i in range(n)] # Find optimized w w_ext = minimize(target, w_ext, constraints=cons).x else: # SVM with slack # Optimize 1/2 w^T * w + C * sum(eps_i) # s.t. yi * (w^T * xi + b) - 1 + eps_i >= 0, eps_i >= 0 c, w_and_eps = 1000, np.hstack((w_ext, np.random.randn(n))) cons = [] for idx in range(n): cons.append({'type': 'ineq', 'fun': get_func_slack_w(idx)}) cons.append({'type': 'ineq', 'fun': get_func_slack_e(idx)}) cons = tuple(cons) w_and_eps = minimize(target_slack, w_and_eps, constraints=cons).x w_ext = w_and_eps[: (p + 1)] # Update and save optimal weights &amp; bias self._w = w_ext[:-1] self._b = w_ext[-1] # Calculate loss pred_val = self._predict_value(x, self._w, self._b) loss = self._loss(pred_val, label) self._update_model(loss) return loss def predict(self, x: np.ndarray, **kwargs) -> np.ndarray: assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) pred_label = self._predict_label(pred_val) return pred_label def evaluate(self, x: np.ndarray, label: np.ndarray, **kwargs) -> tuple: assert x.shape[0] == label.shape[0] assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) pred_label = self._predict_label(pred_val) precision = 1 - np.count_nonzero(pred_label - label) / x.shape[0] loss = self._loss(pred_val, label) return precision, loss @staticmethod def _predict_value(x: np.ndarray, w: np.ndarray, b: np.float) -> np.ndarray: pred_val = np.matmul(x, w) + b return pred_val @staticmethod def _predict_label(pred_val: np.ndarray) -> np.ndarray: pred_label = np.sign(pred_val) pred_label[pred_label == 0] = 1 return pred_label @staticmethod def _loss(pred_val: np.ndarray, true_label: np.ndarray) -> np.float: # Hinge loss loss = 1 - pred_val * true_label loss[loss &lt; 0] = 0 loss = loss.mean() return loss def _grad(self, x: np.ndarray, pred_val: np.ndarray, true_val: np.ndarray) -> None: # Use scipy.optmize to find best w and b # Not grad-base method return Go beyond SVM为了说明问题的本质，我们需要把SVM转换为更一般的形式。 优化问题往往需要把问题的限制去除或者转化为可计算的形式，所以我们对上面的问题表述再做转化： $\\epsilon_i\\ge1-y_i(w^Tx_i+b)\\\\epsilon_i=max[1-y_i(w^Tx_i+b),0]$ 所以优化问题转化为：$\\min{\\Sigma_{i=1}^n\\max[1-y_i(w^Tx_i+b),0]+\\frac{1}{2C}||w||_2^2}$ 这个形式，是不是有点像正则化的线性回归？ 左侧看作目标函数，右侧看作Ridge正则项，则目标函数$l(f)=\\max[1-yf,0]$ 线性回归的目标：$l(f)=(y-f)^2=(1-yf)^2$ 逻辑回归的目标：$l(f)=log(1+e^{-yf})$ 线性分类器的一般形式由上述表示我们可以归纳出线性分类器的问题一般形式： $\\min{\\Sigma_{i=1}^nl(f)+\\lambda R(f)}$ 其中$l(f)$为损失函数，$R(f)$为正则项。 上述模型分别对应以下： 损失函数 线性回归：Square loss 逻辑回归：Logistic loss SVM：Hinge loss 正则项 Ridge：L2-regularizer Lasso：L1-regularizer 不同损失函数关于$yf$的图像： BTW，Hinge loss叫做合叶函数，正是因为它的形状就像打开的合叶。 非线性SVM：核函数刚才我们解决线性问题，那么SVM的能力就仅此而已了嘛？ 能不能对非线性数据也做拟合？ To be continued…","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-04：逻辑回归","slug":"Machine-Learning-04-Logistic-Regression","date":"2019-06-24T16:00:00.000Z","updated":"2019-07-02T16:46:30.795Z","comments":true,"path":"Machine-Learning-04-Logistic-Regression/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-04-Logistic-Regression/","excerpt":"","text":"本文是”机器学不动了”系列的第四篇文章，内容包含了逻辑分类的详细理论和实现。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork与pr。 引子上回说到线性回归相关的理论，那么接下来就顺着线性回归讲解线性分类器。 线性分类器是指分类函数符合$y=w^Tx+b$形式的一系列判别模型，主要包括逻辑回归、支持向量机、感知机等，接下来会首先介绍三个线性分类器本身，再会介绍线性分类器更为一般的形式和广泛的联系。 逻辑回归理论逻辑回归（Logistic Regression）虽然是叫回归，但是实际上是一个分类器。 逻辑回归得名于逻辑函数（Logistic Funtion），也叫做S函数（Sigmoid Function）。 逻辑函数$\\sigma(t)=\\frac{e^t}{1+e^t}=\\frac{1}{1+e^{-t}}$ 这个函数具有以下特征： 可以将$(-\\infty,+\\infty)$之间的输入值映射到$(0,1)$区间 呈现S形，单调递增：输入值为负时输出在$(0,0.5)$之间，非负输出为$[0.5,1)$。 一图胜千言： 这个函数也是逻辑分布的累计分布函数。 逻辑回归使用逻辑函数估计输入参数与类变量的概率，最一般的形式为二分类： $P(y_i=1|x_i,a)=\\sigma(a^Tx_i)=\\frac{1}{1+e^{-a^Tx_i}}$ $P(y_i=-1|x_i,a)=1-\\sigma(a^Tx_i)=\\frac{1}{1+e^{a^Tx_i}}$ 合并二式，有：$P(y_i|x_i,a)=\\sigma(y_ia^Tx_i)=\\frac{1}{1+e^{-y_ia^Tx_i}}$ 或者：$P(y_i|x_i,a)=y_i\\sigma(a^Tx_i)+(1-y_i)(1-\\sigma(a^Tx_i))=y_i\\frac{1}{1+e^{-a^Tx_i}}+(1-y_i)(1-\\frac{1}{1+e^{-a^Tx_i}})$， 或者：$P(y_i|x_i,a)=\\sigma(a^Tx_i)^{y_i}(1-\\sigma(a^Tx_i))^{1-y_i}=…$ P.S.其实合并得到的式子我感觉是凑出来的…… 这就是最基本的逻辑回归的形式。 这个式子也隐含着：判断是类1的概率和类2的概率之和为1。 另外，这两个式子还具有一个规律： $\\frac{P(y_i=1|x_i,a)}{P(y_i=-1|x_i,a)}\\ln\\frac{\\sigma(a^Tx_i)}{1-\\sigma(a^Tx_i)}=a^Tx_i$，所以逻辑回归也叫做对数几率回归。 实际判断的时候，我们会把输出大于0.5的分类作为正类，输出小于0.5的值的分类作为负类，从而学习到一个参数为$w,b$的模型。 目标函数如何评价模型，决定了我们获取参数的方式。 在这里，对于逻辑回归这一个概率模型，我们使用极大似然估计作为目标函数： 我们有对单个输入的概率估计$P(y_i=\\pm1|x_i,a)$（这里使用上面的第三个式子），那么对全体的数据集$D$，总的概率估计为： $P(D)=\\prod_{i\\in I}P(y_i|x_i,a)=\\prod_{i\\in I}(\\sigma(a^Tx_i)^{y_i}(1-\\sigma(a^Tx_i))^{1-y_i})$ 这是一个关于$a$的函数,我们希望$P(D)$取极大，也就是估计正确的概率达到最大。 因而，需要对$P(D)$关于$a$求导。但是，连乘的形式难以求导，所以我们通过取对数把函数形式转化为连加——这在之前的内容也提及了。 $l(P(D))=\\Sigma_{i\\in I}y_ilog(\\sigma(a^Tx_i))+(1-y_i)log(1-\\sigma(a^Tx_i))$ 因为这个函数是凹的，或者说是上凸的，我们再进行一次转换：$E(a)=-\\frac{1}{m}l(P(D))$，可以证明，$E(a)$是一个可导的凸函数。 那么目标函数就变为$E(a)$，我们要求其最小值。 极大似然估计（MLE）在之前的内容已经出现过，不过这里的形式与贝叶斯分类器中的极大似然估计稍有不同，因为这里的估计中，概率就是似然，极大似然估计是对概率与实际分布关系作分析；而贝叶斯分类器中，极大似然估计就是对似然与实际分布的关系作分析（当然，从另一个角度，似然就是后验概率）。 参数估计首先对$E(a)$进行变换： $E(a)=-\\frac{1}{m}\\sum_{i=1}^{m}[y_ilog(\\frac{e^{a^Tx_i}}{1+e^{^{a^Tx_i}}})+(1-y_i)log(\\frac{1}{1+e^{a^Tx_i}})]$ $=-\\frac{1}{m}\\Sigma_{i=1}^m[y_ia^Tx_i+log(1+e^{a^Tx_i})]$ 接下来求梯度： $\\frac{\\partial E(a)}{\\partial a}=-\\frac{1}{m}\\Sigma_{i=1}^m[y_ix_i-\\frac{e^{a^Tx_i}}{1+e^{a^Tx_i}}x_i]$ $=-\\frac{1}{m}\\Sigma_{i=1}^m[y_ix_i-\\sigma(a^Tx_i)x_i]$ 记$\\sigma(a^Tx_i)$为$h_a(x_i)$，那么上式又可以表示为：$-\\frac{1}{m}\\Sigma_{i=1}^m[(y_i-h_a(x_i))x_i]$ 联想一下线性回归的梯度：$\\frac{\\partial E(a)}{\\partial a}=-\\frac{1}{m}\\Sigma_{i=1}^m[(y_i-wx_i+b)x_i]$， 可以说形式非常相似了。 那么和线性回归相似的，我们试着用两种方式求解： 正规方程让梯度为0，我们有：$y_i=\\frac{1}{1+e^{-a^Tx_i}}$ 首先令$z_i=a^Tx_i$，我们有：$y_i=\\frac{1}{1+e^{-z_i}}$ 所以$z_i=-log(\\frac{1}{y_i}-1)=log(y_i)-log(1-y_i)$ 那么我们有$a^Tx_i=log(y_i)-log(1-y_i)$ 看起来是没错，那么能不能代入，通过求解方程组得到$a$呢？ 很遗憾，不能。 我们很快就会注意到，对于$y_i=0,1$，上面这个式子是没有意义的。 那么为什么我们不能用这个方式求解呢？因为梯度是不会等于0的：$\\sigma(z_i)$是不可能达到$0,1$的，所以我们至多是把梯度降低，永远不会出现$y_i=\\frac{1}{1+e^{-a^Tx_i}}$的结果。 所以，正规方程解是不存在的。 梯度下降那么很自然的，我们使用梯度下降法求解。 梯度代入即可，类似线性回归的解： $grad = \\alpha * -\\frac{1}{m}\\Sigma_{i=1}^m[(y_i-wx_i+b)x_i]$ $a-=grad$ 正则化内容相似，参见上一篇文章（线性回归）的有关内容。 代码实现又到了代码实现环节。 这里实现了最基本的逻辑回归LogisticRegression类（不包含正则化部分）。 代码中包含部分注释，如有疑问请在评论区留言。其他详情见我的repo。 import numpy as np from supervised._base import LinearModel from utils import batch class LogisticRegression(LinearModel): \"\"\"Logistic regression model, binary classifier.\"\"\" def __init__(self): super().__init__() def fit(self, x: np.ndarray, label: np.ndarray, **kwargs) -> np.float: # Check labels: only containing 1 and 0 assert np.array_equal(np.unique(label), np.array([0, 1])) assert x.shape[0] == label.shape[0] n, p = x.shape if self._w is None or self._b is None or self._w.shape[0] != p: # Initialize weights using random values self._init_model(p) if kwargs is not None: # Update parameters of training self._update_params(kwargs) iters, loss = 0, 0. # Iterates till converge or iterating times exceed bound while iters &lt; self._iter_bound: iters += 1 # Update weights using mini-batch gradient desent for batch_x, batch_label in batch(x, label, self._batch_size): pred_val = self._predict_value(batch_x, self._w, self._b) loss += self._loss(pred_val, batch_label) * batch_x.shape[0] grad_w, grad_b = self._grad(batch_x, pred_val, batch_label) self._w -= grad_w self._b -= grad_b loss /= n # Break if model converges. if loss &lt;= self._loss_tol: break self._update_model(loss) return loss def predict(self, x: np.ndarray, **kwargs): assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) pred_label = self._predict_label(pred_val) return pred_label def evaluate(self, x: np.ndarray, label: np.ndarray, **kwargs) -> tuple: assert x.shape[0] == label.shape[0] assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) pred_label = self._predict_label(pred_val) precision = 1 - np.count_nonzero(pred_label - label) / x.shape[0] loss = self._loss(pred_val, label) return precision, loss @staticmethod def _predict_value(x: np.ndarray, w: np.ndarray, b: np.float) -> np.ndarray: def __sigmoid(raw: np.ndarray) -> np.ndarray: res = 1 / (1 + np.exp(-raw)) return res prob = np.matmul(x, w) + b pred_val = __sigmoid(prob) return pred_val @staticmethod def _predict_label(pred_val: np.ndarray) -> np.ndarray: pred_label = np.sign(pred_val - 0.5) pred_label[pred_label == 0] = 1 pred_label[pred_label &lt; 0] = 0 return pred_label @staticmethod def _loss(pred_val: np.ndarray, true_label: np.ndarray) -> np.float: # Use maximum likelihood (log-likelihood loss) # loss = 1 / n * (-y * log(wx + b) - (1 - y) * log(wx + b)) # Here we need to care about the log zero and overflow warning... mask_val = pred_val.copy() mask_val[mask_val == 0] = 1e-6 mask_val[mask_val == 1] = 1 - 1e-6 class1_loss = -true_label * np.log(mask_val) class0_loss = (1 - true_label) * np.log(1 - mask_val) loss = np.sum(class0_loss + class1_loss) / true_label.shape[0] return loss def _grad(self, x: np.ndarray, pred_val: np.ndarray, true_label: np.ndarray) -> tuple: # dc / dw = x * (pred_val - true_label) grad_w = (x * (pred_val - true_label).reshape((-1, 1))).mean(axis=0) grad_b = (pred_val - true_label).mean() # Use simple gradient by multiplying learning rate and grad. grad_w *= self._learn_rate grad_b *= self._learn_rate return grad_w, grad_b 推广：从二分类到多分类见本系列的第一篇文章（机器学习概念）","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-03：线性回归","slug":"Machine-Learning-03-Linear-Regression","date":"2019-06-22T04:00:00.000Z","updated":"2019-06-25T07:38:56.295Z","comments":true,"path":"Machine-Learning-03-Linear-Regression/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-03-Linear-Regression/","excerpt":"","text":"本文是”机器学不动了”系列的第三篇文章，内容包含了线性回归的详细理论和简单线性回归的实现。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork与pr。 引子上回讨论了贝叶斯模型，这一模型属于生成模型（Generative Model），基于一定的假设，认为样本是由类按照一定概率模型产生的，然后根据样本学习数据。 同时我们注意到，在高斯贝叶斯分类器中，如果所有类别共享权重，那么模型就转化为线性的表达式，从而可以使用形如$y=w^Tx+b$的简洁形式建模，直接求出描述分类面的表达式（详见上次附录的证明），这就是判别模型（Discriminant Model）的思路。 那么接下来我们将深入讨论判别模型，这是直接根据数据学习得到的更加直接的规律。 线性模型就是一种判别模型，这一次我们讨论它在回归任务上的应用，也就是线性回归。 线性回归理论对$x=[x_1,x_2,x_3,…,x_d]^T\\in R^d$，线性函数的形式为$y=w^Tx+b$，其中$w=[w_1, w_2,…, w_d]\\in R^d$，$b\\in R$。 这一表达式还有一种表述，那就是将$b$这一项加入$w$中，变成： $x=[x_1,x_2,…,x_d,1]^T\\in R^{d+1},w=[w_1,w_2,…,w_d,b]^T\\in R^{d+1}$ 简单的模型蕴含着不可小视的力量。任意模型的表达式都可以转化为线性组合，故也可以转化为线性模型。 比如，多项式可以转化为线性组合的形式： $f(x,a)=a_0+a_1x+a_2x^2+…+a_Mx^M=\\Sigma_{i=0}^Ma_ix^i$ 可以转化为：$f(x,a)=A^TX$，其中： $X=[1,x,x^2,x^3,…,x^M]^T,a=[a_0,a_1,a_2,…,a_M]^T$ 基本理论部分十分简洁明了。 目标函数这里目标函数通常使用最小二乘误差（Mean Square Error）： $J_n(a)=\\frac{1}{N}\\Sigma_{i=1}^N(y_i-a^Tx_i)^2=(y-X^Ta)^T(y-X^Ta)$ 当然，使用平方残差（Residual Sum of Squares）也是可以的，区别在于比最小二乘误差少了系数$\\frac{1}{N}$。 你可能会问，为什么不使用平均绝对值误差（Mean Absolute Error）：$J_n(a)=\\frac{1}{N}\\Sigma_{i=1}^N|y_i-a^Tx_i|$，但是它存在一些缺陷： 在零点处不可导。 其导出的梯度是常数（+1或者-1），梯度求解容易导致不收敛。 接下来我们抱着让目标函数最小化的目标，对它求梯度： $\\nabla J_n=-\\frac{2}{N}X(y-X^Ta)$ 然后就可以开始愉快地参数估计啦（＾∇＾） 参数估计这里我们有两种估计方法：基于正规矩阵（Normal Equation）的直接求解，或者给予梯度下降的迭代法。 正规矩阵由上面的梯度，我们直接令梯度为0： $a=(XX^T)^{-1}Xy$，这就是理论最优解——因为梯度为0，目标函数是完全凸的，所以可以认为训练数据的目标函数达到了最小值。 如果$XX^T$非奇异，那么我们可以获得唯一解（奇异情况下使用伪逆，理论上应该是有无数组解）。 特别地，如果$X$是方阵（一般不是），那么$a=X^{-T}X^{-1}Xy=X^{-T}y$。 好，然后我们看一下梯度求解的做法： 梯度下降如果你还不知道梯度下降是什么的话，我在第一篇文章里已经写过梯度下降、批量梯度下降/随机梯度下降这些概念。 通过迭代的方式更新参数，只需要把梯度乘上一个学习率$\\alpha$就可以： $grad=\\alpha * -\\frac{2}{N}X(y-X^Ta)$ $a-=grad$ 通常，常数项$\\frac{2}{N}$会省去，因为学习率是一个可以缩放的值。 好了，这里再次提出第一篇文章的问题，为什么第一种方法看起来简单直接，而且能够得到确定的“精确解”，而实际操作往往使用基于梯度的做法呢？看起来第二种做法很不精确，而且似乎未必收敛到正确的解。 理由就是，第一个方法的实质是计算方程组的解，涉及求逆矩阵的过程，但是一来计算量大，二来难以保证矩阵非奇异或者非病态的情况下，计算过程对方程组值的扰动非常敏感，噪声带来的误差较大导致结果偏离理论解。 代码实现又到了动手实践的时间了。这一次实现了LinearRegression类基于LinearModel基类，并实现了其抽象方法。在这一份代码中不但实现了基于梯度下降的迭代方法，也实现了基于normal equation的直接求解法。 暂时没有实现Ridge和Lasso的正则部分，主要是希望和其他线性分类器一同构思实现，把正则化做一个更佳泛用型的模块。 代码中已经给出部分注释，如有疑问请在评论区留言。其他详情请见我的repo。 import numpy as np from supervised._base import LinearModel from utils import batch class LinearRegression(LinearModel): \"\"\"Linear regression model.\"\"\" def __init__(self): super().__init__() def fit(self, x: np.ndarray, y: np.ndarray, **kwargs) -> np.float: assert x.shape[0] == y.shape[0] n, p = x.shape if self._w is None or self._b is None or self._w.shape[0] != p: # Initialize weights using random values self._init_model(p) if kwargs is not None: # Update parameters of training self._update_params(kwargs) iters, loss = 0, 0. # Iterates till converge or iterating times exceed bound while iters &lt; self._iter_bound: iters += 1 # Update weights using mini-batch gradient desent for batch_x, batch_y in batch(x, y, self._batch_size): pred_val = self._predict_value(batch_x, self._w, self._b) loss += self._loss(pred_val, batch_y) * batch_x.shape[0] grad_w, grad_b = self._grad(batch_x, pred_val, batch_y) self._w -= grad_w self._b -= grad_b loss /= n # Break if model converges. if loss &lt;= self._loss_tol: break # Update model with current weight and bias self._update_model(loss) return loss def fit_norm_eq(self, x: np.ndarray, y: np.ndarray) -> np.float: # Fit x using normal equation assert x.shape[0] == y.shape[0] n, p = x.shape if self._w is None or self._b is None or self._w.shape[0] != p: # Initialize weights using random values self._init_model(p) x_ext = np.hstack((np.ones((n, 1)), x)) w_ext = np.linalg.pinv(np.matmul(x_ext.T, x_ext)) w_ext = np.matmul(np.matmul(w_ext, x_ext.T), y) self._w, self._b = w_ext[1:], w_ext[0] # Calculate training loss pred_val = self._predict_value(x, self._w, self._b) loss = self._loss(pred_val, y) self._update_model(loss) return loss def predict(self, x: np.ndarray, **kwargs) -> np.ndarray: assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) return pred_val def evaluate(self, x: np.ndarray, y: np.ndarray, **kwargs) -> tuple: assert x.shape[0] == y.shape[0] assert not np.isinf(self._optimum['loss']) assert self._optimum['w'].shape[0] == x.shape[1] pred_val = self._predict_value(x, self._optimum['w'], self._optimum['b']) # The precision part of regression is None precision = None loss = self._loss(pred_val, y) return precision, loss @staticmethod def _predict_value(x: np.ndarray, w: np.ndarray, b: np.float) -> np.ndarray: pred_val = np.matmul(x, w) + b return pred_val @staticmethod def _predict_label(pred_val: np.ndarray) -> np.ndarray: # NO labeling in regression. pass @staticmethod def _loss(pred_val: np.ndarray, true_val: np.ndarray) -> np.float: # Use MSE loss loss = float(np.sum(np.power(pred_val - true_val, 2))) loss /= 2 * true_val.shape[0] return loss def _grad(self, x: np.ndarray, pred_val: np.ndarray, true_val: np.ndarray) -> tuple: # Use MSE loss grad_w = (x * (pred_val - true_val).reshape((-1, 1))).mean(axis=0) grad_b = (pred_val - true_val).mean() # Use simple gradient by multiplying learning rate and grad. grad_w *= self._learn_rate grad_b *= self._learn_rate return grad_w, grad_b 正规化好了，我们的模型看起来很完美不是吗？ 现在我们试着用线性模型去拟合开头提到的多项式曲线$f(x,a)=a_0+a_1x+a_2x^2+…+a_Mx^M=\\Sigma_{i=0}^Ma_ix^i$ 假如图线长这样，$y=sin(x)$： 这种图线，0阶、1阶都是单调，2阶又不能先凹后凸，看起来都拟合不了啊。 直接上三阶试试： 看起来还行，但是没办法做到完美贴合。 我们试试更厉害的，让M=9： 嚯，厉害了，要不是背景把真实曲线画出来我还真就信了。 虽然做到训练误差为0，但是我们有理由相信，在真实数据上测试结果一定惨不忍睹。 结果如下： 很明显，模型过拟合了。于是可以复习一下第一篇文章关于偏差与方差的理解： 模型越复杂（组成模型的参数越多），方差越大，偏差越小，这是因为模型的描述能力越强；模型越简单，偏差也容易大，很可能无法拟合训练数据。 我们还发现一个特征，那就是越高阶的那个系数绝对值越大： 为了避免过拟合，我们引入一种叫做正规化（Regularization）的技巧。 下面介绍两种正规化技巧，Ridge与Lasso。 Ridge我们使用二阶残差作为目标函数，并引入一个惩罚项，变为： $a^*=argmin\\Sigma_{i=1}^N(y_i-x_i^Ta)^2+\\lambda\\Sigma_{j=1}^pa_j^2=(y-X^Ta)^T(y-X^Ta)+\\lambda a^Ta$ 计算梯度得到：$\\nabla a=-2X(y-X^Ta)+2\\lambda a$ 用正规方程的方法，我们可以得到：$a^*=(XX^T+\\lambda I)^{-1}Xy$，其中$\\lambda$是一个常数。 再次求解，我们惊奇的发现，高阶的系数变小了： 这就比较耐人寻味了。从理论角度分析一下这个事实： 岭回归以增大偏差为代价，换取更小的方差——这是随着$\\lambda$增大，模型发生的变化。 在这个多项式中，因为很明显地看到随着模型变得复杂，模型的方差越来越大，岭回归正是降低方差的手段。 不仅如此，岭回归更大的用处在于。当我们的特征存在较强的线性相关性的时候（可以说在特征方面不满秩），会导致$XX^T$的值很小，甚至趋于奇异。而岭回归会帮我们限制参数绝对值的大小，抑制相关性较强的属性系数。 所以，岭回归实际上并不只是用在刚才的多项式拟合上，而是对所有存在较多线性相关属性时的通用解决方式。个人理解有点类似“降维”的操作，但是稍有不同。数学上使用术语压缩估计（shinkage）描述这一操作。 Lasso和Ridge相似，唯一的不同在于惩罚项的阶数： $a^*=argmin\\Sigma_{i=1}^N(y_i-x_i^Ta)^2+\\lambda\\Sigma_{j=1}^p|a_j|=(y-X^Ta)^T(y-X^Ta)+\\lambda ||a||_1$ 它带来的影响也稍有不同，会导致模型的参数大多变成0，也就是得到稀疏化的参数。 用一幅图直观理解： 红色的椭圆和蓝色的区域的切点就是目标函数的最优解，我们可以看到，如果是圆，则很容易切到圆周的任意一点，但是很难切到坐标轴上，因此没有稀疏；但是如果是菱形或者多边形，则很容易切到坐标轴上，因此很容易产生稀疏的结果。这也说明了为什么Lasso会是稀疏的。 从量化的偏差、方差与噪音的角度看待正则化（待补充说明）到这里我们从量化的角度来看这三个概念： 我们用一个概念来代表模型的总误差：Expected Prediction Error，EPE。 量化的计算如下（目前我对这部分理解不深，这一部分待补充）： $EPE(f)=\\int\\int(y-f(x))^2p(x,y)dxdy$ $EPE=var+bias^2+noise$ $bias^2=\\int{E_D(f(x;D))-E(y|x)}^2p(x)dx$ $variance=\\int E_D{[f(x;D)-E_D(f(x;D))]^2}p(x)dx$ $noise=\\int var(y|x)p(x)dx$ 这里贴出不同$\\lambda$参数对偏差与方差的影响： 可以很明显的看出，正则项降低了图线的拟合程度，但是也降低了方差（即不同预测线的变化幅度）。 从而，我们对Bias-Variance的Trade-off有了更深的理解：","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-02：贝叶斯分类","slug":"Machine-Learning-02-Bayes","date":"2019-06-21T04:00:00.000Z","updated":"2019-06-25T07:38:48.588Z","comments":true,"path":"Machine-Learning-02-Bayes/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-02-Bayes/","excerpt":"","text":"本文是”机器学不动了”系列的第二篇文章，内容包含了贝叶斯分类的详细理论和简单高斯贝叶斯分类器的实现。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork与pr。 引子贝叶斯分类的核心是贝叶斯公式： $P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$ $P(A) = \\Sigma_{i=1}^n{P(B|A_i)P(A_i)}$ 贝叶斯公式对多元变量同样适用，与变量是否独立也无关，是普适的公式。 为了介绍这个公式，我们首先来看一道概率题： 现分别有 A、B 两个容器，在容器 A 里分别有 7 个红球和 3 个白球，在容器 B 里有 1 个红球和 9 个白球，而设定从A中抽取的概率和B中抽取的概率为1:2。 现已知从这两个容器里任意抽出了一个红球，问这个球来自容器 A 的概率是多少? 记抽中红球的事件为$P(B)$，记从容器A抽球的概率为$P(A)$。 根据贝叶斯公式，我们有：$P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$。其中$P(B|A)$表示从容器A中抽球，抽到红球的概率。 在这个公式中： $P(A|B)$是已知B发生后A的条件概率，也叫做A的后验概率（posterior probability）。 $P(B|A)$是已知A发生后B的条件概率，是B的后验概率，在这里叫A的似然概率（likelihood）。 $P(A)$是事件发生之前我们对A的经验知识，与B无关，叫做A的先验概率（prior probability）。 $P(B)$是B的先验概率，在这里叫做标准化常量（normalized constant）。 根据这个关系，后验$P(A|B)$也可以叫做标准化的似然；似然和后验是可以相互转化的。 贝叶斯分类理论从这个公式引申开，我们可以套用在分类理论上： 我们可以类比认为每一个类对应一个容器，样本都是这个类中生成（取出）的。 分类问题可以采用这样的表述：已知一个待归类样本$X_i$的特征，那么求$X_i$属于第j个类的概率，就变成了一个后验概率。 把样本属于第j个类的概率记作事件$w_j$，这个后验概率可以表述为：$P(w_j|x=X_i)$，简记作$P(w_j|X_i)$。 那么，根据贝叶斯公式，我们有：$P(w_j|X_i)=\\frac{P(X_i|w_j)P(w_j)}{P(X_i)}$。 这里的似然是$P(X_i|w_j)$，先验概率是$P(w_j)$，标准化常量为$P(X_i)$。 那么，有了某个样本属于各个类别的概率，如何分类呢？ 很自然的，我们选择后验概率比较大的那一个概率对应的类别作为$X_i$的分类。 补充1：当我们只有先验概率的时候，我们选择先验概率较大的那一个类别作为分类。用先验概率直接估计的坏处在于”马太效应”，因为它总是把新样本归类到原本占多数的那一个类。 补充2：当采用风险矩阵（risk matrix）进行评估的时候，分类规则会更复杂一些。 参数估计我们已经有了概率的公式和决策理论，如何估计概率公式中的各个概率？ 答案是：从有类标签的数据（训练数据）中总结提取。 先验概率的估计这里的先验概率，就是在没有训练样本具体特征的值的分布情况下，某个类原始的信息。 很自然的，我们会把这个类别的样本数占全部有标签的样本的比重当作先验概率， 即：$P(w_j)=\\Sigma_{i=1}^N{I(y_i=c_j)}/N$ 似然概率的估计这里我们需要分为连续变量和离散变量两种情况讨论： 连续变量我们有不同的假设可以做出不同的估计。常用的有高斯分布假设、二项分布假设、伯努利分布。 这里只介绍高斯分布假设对应的参数估计方法。 高斯分布的具体假设：对于某一个类$c_i$，其生成的样本满足高斯分布，即：$X\\sim N(\\mu, \\Sigma)$，其产生的每一个样本之间的概率是互相独立且同分布的（i.i.d，Independent and identically distributed） 在这里我们采用极大似然估计（Maximum Likelihood Estimation）的做法来选取最佳参数： 目标函数是$L(\\mu_j,\\Sigma_j)=\\prod_{i=1}^N{P(X_i|w_j)}$。 由于不方便对目标函数求导，我们采用取对数的技巧，将连乘转化为连加：$l(\\mu_j,\\Sigma_j)=log(L)=\\Sigma_{i=1}^NP(X_i|w_j)$ 对对数似然求导，令导数为0求出$\\mu,\\Sigma$。由于样本是多维，求导过程比较复杂，详情参考附录。 总之，最终求出的结果和标量形式的惊人一致： $\\hat\\mu_j=\\frac{1}{N_j}\\Sigma_{i=0}^{N_j}X_i=\\bar{x}$ $\\hat\\Sigma=\\frac{1}{N_j}\\Sigma_{i=1}^{N_j}(X_i-\\hat\\mu)(X_i-\\hat\\mu)^T=cov(X_i), where\\ y_i = w_j$ 很容易联想到标量情况下，$\\hat\\mu=\\bar{X}, \\hat\\sigma=var(X)$ 有了估计的参数以后，我们可以通过高斯概率密度公式求似然概率：$P(X; \\mu, \\Sigma)=\\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}exp(-\\frac{1}{2}(X-\\mu)^T\\Sigma^{-1}(X-\\mu))$ P.S.其实我有一点疑问🤔️，为什么这里不能使用梯度求解而是直接令梯度为0求解证明的呢，有没有大佬能够在评论区说一说自己的想法…… 离散变量对于离散变量的估计则较为简单，我们选取以前这一特征出现过的值的分布情况作为估计，即： $P(X_i^k|w_j)=\\frac{|X_i^k|}{N_{w_j}}$ 比如在某个类的性别特征中，男性出现了100次，女性出现了200次，我们就估计一个这个属性为男性的似然概率为100/300=0.33333…，对女性同理。 标准化常量 对于连续变量来说，理论上是通过$P(X_i)=\\Sigma_{j=1}^cP(X_i|w_j)P(w_j)$求出概率密度，也就是说得算出对样本对每一个类的先验概率和似然的乘积之和，才能计算分母。 对于离散变量来说，则是求出这一个一模一样的样本在训练数据中出现的次数。 如果过去没有出现过这一样本，我们总不能把0作为它的概率，这是不合理的（一来有可能是样本数量过少，二来人家是分母啊，怎么能是0），所以采用平滑（Smoothing）的技术，在分子分母同时加入一个与样本数有关的平滑项。具体技术在此不做详细介绍。 然而正常情况下，它并不在我们的考虑范围内： 因为，每一个类的计算概率的分母都是这一项。既然我们最终的目标是比较后验概率的大小（或者与风险矩阵关联后的大小，whatever），这一项作为相同的系数并不会产生影响：） 目标函数在这里因为我们并不是采取迭代优化，而是通过假设模型直接估计得出参数，所以不需要目标函数可导。 采用0-1损失函数就可以，即分类错误，结果就加一，分类正确结果就不变化的函数。 在贝叶斯中分类中，还有一个常见的评价标准（metrics）：混淆矩阵和风险矩阵，具体见上一篇的后半段。 朴素贝叶斯朴素贝叶斯（Naive Bayes）模型是贝叶斯模型的一个变种，是简化贝叶斯参数的一种模型。 在朴素贝叶斯中，我们认为各个特征之间是独立的，互相不会影响，即： $P(X_i|w_j)=P(X^1_i,X^2_i,X^3_i,…X_i^p|w_j)=P(X_i^1|w_j)P(X_i^2|w_j)P(X_i^3|w_j)…P(X_i^p|w_j)$ $=\\prod_{k=1}^pP(X_i^k|w_j)$ 将这一假设应用在高斯模型中，贝叶斯-高斯模型的$\\Sigma$参数就退化为对角矩阵，因为它本质是协方差矩阵，如今各个特征之间的协方差为0，每个特征服从独立的高斯分布。 所以计算公式也变得简单，只需要单独计算每一维度的高斯分布概率再相乘就可以计算。 朴素贝叶斯分类器至今也是一个简单的流行分类器，不过在很多时候，样本的属性往往是相关的，这种情形下使用朴素贝叶斯模型就不太好。 代码实现好了，说了这么多终于要上代码了～ 这里实现了高斯贝叶斯多分类器，继承自SupervisedModel基类（详见本人的repo），主要方法实现了fit,predict,evaluate，代码中包含一定的注释，如有疑问可以在评论区留言。 import numpy as np from supervised._base import SupervisedModel class Bayes(SupervisedModel): \"\"\"Bayes model, multi-class (or binary) classifier. Bayes models include Gaussian, Multinomial, Bernoulli, however here I only implemented Gaussian. \"\"\" def __init__(self): self._prior_dict = None self._mean_dict = None self._cov_dict = None self._cov_all = None self._p = None def fit(self, x: np.ndarray, label: np.ndarray, **kwargs) -> np.float: assert x.shape[0] == label.shape[0] n, p = x.shape if self._mean_dict is None or self._cov_dict is None \\ or self._prior_dict is None or self._p != p: self._prior_dict = {} self._mean_dict = {} self._cov_dict = {} self._p = p # Calculate mean and co-variance matrix for each class all_class = np.unique(label) for c in all_class: group = x[label == c] mean, cov = self.__param_gaussian(group) self._prior_dict[c] = group.shape[0] / n self._mean_dict[c] = mean self._cov_dict[c] = cov # Calculate the whole co-variance matrix _, cov = self.__param_gaussian(x) self._cov_all = cov # Calculate loss on x _, loss = self.evaluate(x, label) return loss def predict(self, x: np.ndarray, **kwargs) -> np.ndarray: assert self._cov_dict is not None and self._mean_dict is not None assert self._cov_all is not None assert self._p == x.shape[1] # Default: non-linear classifier linear = False if 'linear' in kwargs: assert isinstance(kwargs['linear'], bool) linear = kwargs['linear'] # Calculate posterior propability for each class # All class share a same co-variance matrix if linear == True prob, label_list = [], [] for c, mean in self._mean_dict.items(): if linear: cov = self._cov_all else: cov = self._cov_dict[c] prior = self._prior_dict[c] current_prob = self.__posterior_gaussian(x, prior, mean, cov) prob.append(current_prob) label_list.append(c) # Get index of class having maximum probability for each x pred_val = np.argmax(prob, axis=0) label_list = np.array(label_list) pred_label = label_list[pred_val] return pred_label def evaluate(self, x: np.ndarray, label: np.ndarray, **kwargs) -> tuple: pred_label = self.predict(x, **kwargs) # Calculate 0-1 loss loss = np.count_nonzero(pred_label - label) # Use loss to calculate precision precision = 1 - loss / x.shape[0] return precision, loss @staticmethod def __param_gaussian(x: np.ndarray) -> tuple: \"\"\"Estimate mean and variance.\"\"\" mean = x.mean(axis=0) diff = x - mean cov = np.matmul(diff.T, diff) / x.shape[0] return mean, cov @staticmethod def __posterior_gaussian(x: np.ndarray, prior: np.float, mean: np.ndarray, cov: np.ndarray) -> np.ndarray: \"\"\"Calculate posterior probability P(wi | x).\"\"\" # Calculate likelihood probability: # P(xj | wi) ~ 1 / sqrt(det(cov)) # * exp(-0.5 * (xj - mean)^T * cov^(-1) * (xi - mean)) diff = x - mean coef = np.power(np.linalg.det(cov), -0.5) inv = np.linalg.pinv(cov) # Get exponent for xj (0 &lt; j &lt; n) exponents = np.apply_along_axis( lambda row: np.float(np.matmul(row, inv).dot(row)), 1, diff) likelihood = coef * np.exp(-0.5 * exponents) # Posterior = prior * likelihood / evidence (omitted) posterior = prior * likelihood return posterior 拓展：分类面形状一般而言，贝叶斯分类器并不是一个线性分类器。 高斯模型不同类之间的分类面是高斯面之间的相交面，和每个类的模型参数有关。 用二维特征、多分类的高斯分类面的图像说明会更清晰（概率密度表现为图像中的高度z值，不同的峰表示不同类的中心概率密度）： 限制了二维特征与二分类的高斯分布模型之后，分类面其实有一些有趣的规律，这是由高斯分布的形状造成的。 这里以二分类、二维特征的高斯分类模型为例说明这一点，下图展示了不同的参数（$\\mu,\\Sigma$）带来分类面的不同： 对应的概率分布三维图： 那么，高斯模型的参数又是如何影响分类面形状的呢？ 可以证明有以下结论（证明见附录）： 类的$\\mu$参数不会影响分类面的性质（线性/非线性），只会改变类在高维空间的中心位置。 如果所有特征均是独立分布，且所有类共享协方差矩阵，即：$\\Sigma_j=\\sigma^2I$，那么分类面是线性的，且两个类之间的分类直线垂直类中心之间的连线。 如果所有特征均共享协方差矩阵，即：$\\Sigma_j=\\Sigma=cov(X)$，那么分类面也是线性的，但是直线会存在一定的倾斜。 如果不满足这两个条件之间的任意情况，那么分类面是圆锥曲线（抛物线、双曲线、圆……）。 特点 对偶尔的数据噪声鲁棒性好，因为使用了假设模型，相当于模型的信息不完全来自数据。 但是也因为模型自带假设，在不满足假设情形的数据上拟合效果不好。 附录：多维高斯参数估计推导（Deriving the Maximum Likelihood Estimators）来源：https://stats.stackexchange.com/questions/351549/maximum-likelihood-estimators-multivariate-gaussian 或者查看文档版本：https://people.eecs.berkeley.edu/~jordan/courses/260-spring10/other-readings/chapter13.pdf 高斯分布参数与分类面形状证明来源：https://www.byclb.com/TR/Tutorials/neural_networks/ch4_1.htm 由于证明讨论过长，篇幅所限，在此不贴出详细证明内容。","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-01（上）：机器学习综述","slug":"Machine-Learning-01-Overview","date":"2019-06-20T16:00:00.000Z","updated":"2019-07-02T18:08:24.259Z","comments":true,"path":"Machine-Learning-01-Overview/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-01-Overview/","excerpt":"","text":"本文是”机器学不动了”系列的第一篇文章的上半部分，内容包含了机器学习的理论综述、算法分类。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork和pr。 引子如今深度学习、数据挖掘、机器学习这些概念已经🔥到成为满大街都是的概念，由于其门槛低（调包）和某些fancy的功能，加上媒体的宣传和高薪的诱惑，无论计算机专业还是非计算机专业出身的人们都热衷于在其中寻找机会，我这个软工的菜🐔也不例外。当然，目前正处于新手期。 这一个系列主要记录了我在ZJU上数据挖掘课学习和梳理的机器学习的知识，并且包含一些额外的补充知识。具体内容包括了数学理论和代码实现，希望能够给入门者（包括我自己）提供一个参考。 由于本人懒癌晚期，博客将不定期更新。 读者如果有问题或者留言可以直接在相关的博文下面留言，可以共同探讨解决。 当然也可以邮件联系本人：lilq1285@163.com，欢迎理性讨论。 本系列内容属于个人原创，转载请声明出处，商业转载请联系本人，邮箱同上。 机器学习总览机器学习发源于统计学，主要的目标是用数学和程序语言描述事物的规律，从而为预测、决策提供参考。 以全局的视角来看机器学习这一领域的算法，主要分为有监督（Supervised）学习和无监督（Unsupervised）学习两类，此外还有半监督（Half-supervised）学习、强化（Reinforcement）学习： 有监督学习主要任务 回归（Regression）通常目标是得到连续的曲线，输出是连续的值 分类（Classification）通常目标是得到决策的边界，输出的是离散的类别 常见算法 Linear Regression：线性回归，以线性方式组合特征拟合连续曲线 Bayes：贝叶斯分类，通过概率模型计算样本属于各个分类的后验概率，进行分类 Logistic Regression：逻辑回归，在线性回归基础上增加激活函数以进行分类 Support Vector Machine：支持向量机，选取决策面较近的点用来计算决策面的参数 K Nearest Neighbor：K近邻，寻找距离较近的K个样本的标签取众数作为样本归类 Perceptron：感知机，二分类算法，最简单的神经网络 Decision Tree：决策树，可以看作从样本数据中学习if-else语句的组合，每一个判断都是数的一个节点，实现分类 Linear Discriminant Analysis：线性判别分析，通过找到特征的线性组合以用于降维，也是一种分类算法 算法的分类 如果从算法解决的问题分类，可以分为回归和分类两大类算法： 其中，线性回归为回归类的算法，其余算法均主要用于分类，当然也可以有回归的作用。因为这些分类算法大多是在连续的输出外进行处理获得类别，如逻辑回归、感知机、支持向量机等，如果用在回归上则输出的是分类前计算的结果。 如果从决策面的角度来看，上述的分类算法可以分为线性分类算法和非线性分类算法： 线性分类算法：分类面为线性/输出函数为线性形式（本质相同，采用不同的目标函数得到的模型） 包括：逻辑回归、支持向量机、感知机、线性判别分析 非线性算法：分类面为非线性/输出函数的形式为非线性 包括：贝叶斯、K近邻、决策树 如果从算法的实际含义角度看，上述的分类算法可以分为生成模型和判别模型： 生成模型：按照条件概率建立模型，基于高斯分布等假设，学习模型的参数用于分类 包括：贝叶斯模型、线性判别分析 判别模型：出于最大化在测试集上的表现，进行训练 包括：大部分其他分类算法 在基本算法的基础上，现代机器学习常见的还有集成（Ensemble）学习，其核心是”三个臭屁匠，顶个诸葛亮”，并不致力于产生最强的单个分类器，而是通过把训练不同的较弱分类器，并进行集合决策以获得最好的分类效果。 集成学习 Bagging/Bootstrap Aggregating：通过随机切分数据集，并行训练相同模型以获得更好的分类效果。 随机森林（Random Forest）算法正是基于bagging算法实现。 Boosting：通过训练一系列弱分类器并组合获得强分类器。 Stacking：训练一个组合不同模型的高层模型进行分类（上面两种算法对底层模型的组合方式是确定的）。 无监督学习主要任务 降维（Dimensionality Reduction）指的是将样本空间从高维特征投影到较低维度的特征从而实现提高计算效率的作用。 聚类（Clustering）指的是将无标签的样本按照样本之间的距离信息等，将相近的样本归为一个簇的算法，可以理解为没有样本标签的分类算法。 常见算法 Principle Component Analysis：主成分分析，通过提取协方差矩阵中的特征向量作为新特征实现降维。 与线性判别分析（LDA）相似的算法。 K Means：K均值算法，通过抽取相近点簇的重心作为簇的代表来实现聚类。 K Medoids：K中心点算法，和K Means算法相近，不同的是选取簇中最接近重心的点作为簇的代表。 Spectral Clustering：谱聚类，通过降维方法和K Means算法实现聚类。 Gaussian Mixture Model：高斯混合模型，是基于高斯分布的假设，通过点簇的分布估计参数以实现聚类。 K Means算法可以视为GMM的一种特殊形式。 Matrix Factorization：矩阵分解，是一类降维算法，包括奇异值分解、矩阵非负分解和稀疏编码等算法。 算法的分类 如果按照主要任务，可以将算法分为降维算法和聚类算法： 降维算法：主要包括主成分分析、矩阵分解 聚类算法：主要包括K均值、K中心点、谱聚类、高斯混合模型 半监督学习利用少量标注样本和大量未标注样本进行机器学习的算法。 由于本人并不了解这一块，所以此处内容不作详细介绍，有兴趣者请自行谷歌。 强化学习没有特定的目标，强调环境的反馈作用，通过应对环境调整策略的算法。 由于本人并不了解这一块，所以此处内容不作详细介绍，有兴趣者请自行谷歌。 深度学习这一块是近十年新的方向，也是目前机器学习最火的分支，但是预计不会在近期内容中出现。 简言之，深度学习就是基于神经网络的算法，通过组合线性的神经元和非线性的激活层，以及搭建不同结构的网络，来实现回归或者预测、聚类等工作。 其”神经网络”形态的灵感得益于生物大脑的神经元连接结构，让人联想到”机器的大脑🧠”，加上诸如alphaGo等等一些新奇的成就带来的狂热使得众人为之疯狂，许多营销号和媒体甚至脑洞大开，大肆鼓吹”人工智能有害论”。 但目前而言，可解释性差、缺乏较统一的数学理论描述是其硬伤。而且也没有出现强人工智能的迹象，目前的神经网络，本质只是一种复杂的统计模型。 随着研究陷入瓶颈，这场资本与舆论的狂欢已经在逐渐冷却，未来究竟如何发展也未可知：） 机器学习方法论机器学习的本质在于从数据或者假设中建立模型、学习参数，去拟合一个未知的函数。 根据论文《A Few Useful Things to Know about Machine Learning》，机器学习的过程可以表示为： $LEARNING = REPRESENTATION + EVALUATION + OPTIMIZATION$ 也就是说，机器学习主要分为三个过程： 表示（Representation）：使用计算机能够执行的语言描述算法。这个阶段确定了模型的类型，所以决定了拟合/分类函数的假设空间（Hypothesis Space）——也就是说，在这一步，模型的参数个数和模型的计算方式已经确定，比如线性模型的$y=WX+B$，那么模型无法模拟非线性的分类/回归，这是选取的模型导致的。而具体是如何线性的函数，需要在接下来的过程中确定。 评估（Evaluation）：用于评估模型的好坏。根据任务的不同（回归、分类）确定了不同的种类，同时这个评估方法应当是能够方便地找到对应的优化函数的（更明确一点，评估的函数应该是可导的）。我们训练的目标就是最小化目标函数（误差型）或者最大化目标函数（精度型）。 优化（Optimization）：评估函数就像考试，有了考试我们就可以知道自己的薄弱环节，从而确定努力的方向。而有了评估函数，就有一个对应的优化函数用于调整模型的参数。 通常我们采用基于梯度的方法，具体会在下面梯度下降这一概念中解释。 论文中列出了一个关于这三个部分的表格，在这里贴出来： 从表格也可以看出来，对某一种算法，并非所有的评估函数都能够使用，有些算法是绑定了评估函数的。 同时，评估函数与优化函数存在对应关系，选择某一类评估函数时，对应的优化策略也就决定了。 （接下篇：机器学习概念）","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-01（下）：机器学习概念","slug":"Machine-Learning-01-Overview-2","date":"2019-06-20T16:00:00.000Z","updated":"2019-06-25T07:28:24.917Z","comments":true,"path":"Machine-Learning-01-Overview-2/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-01-Overview-2/","excerpt":"","text":"本文是”机器学不动了”系列的第一篇文章的下半部分，内容包含了机器学习的概念解释。 全系列推荐结合个人实现的代码食用：https://github.com/Riroaki/LemonML/ 欢迎star、fork和pr。 引子紧接上半篇文章的算法介绍，这里主要会介绍一些基本概念。 预处理特征缩放特征缩放（Feature Scaling）是一项预处理技术，它将所有的输入按照统一的标准进行处理： 最大最小缩放（Min-Max Normalization）：把每一个特征的各个值按照大小缩放到$[0,1]$的区间中。 均值缩放（Mean Normalization）：把每一个特征的各个值按照大小缩放到$[-1, 1]$区间中。 标准化（Standardization）：把每一个特征缩放成平均值为0，方差为1的变量。 单位化（Scaling to Unit Length）：把每一个样本的长度（即向量的第二范数）缩放为1。 评估泛化 、方差、偏差和噪声首先，泛化（Generalization）是指模型在经过一定的数据训练之后对现实数据进行测试，我们希望模型能够最小化测试误差（testing error），而训练数据集上的误差与测试数据集上的误差就是泛化误差（Generalization Error）。 而泛化误差分为方差（Variance）与偏差（Bias），通过这两个方面可以描述模型与现实模型的误差： Bias是模型预测与真实结果的差距，可以直观理解为训练误差（training error），表现了模型的拟合能力； Variance则是“（大小相同的）不同训练数据集训练出的模型”的训练误差之间的差异，表现了数据扰动的影响。 通常来说，模型越复杂（组成模型的参数越多），方差越大，偏差越小，这是因为模型的描述能力越强；模型越简单，偏差也容易大，很可能无法拟合训练数据。 通常模型复杂程度与方差/偏差的关系： 在图中可以看到，随着模型变得复杂，训练误差/偏差变小，而方差（在图中可以看作测试误差与训练误差之间的差值）变大，训练误差在中间有一个较低值。 由此启发我们寻找一个复杂度的平衡点，使得模型具有较低的bias和variance；至于noise则是无法改变的。 此外，还有一个概念叫做噪声（noise）：噪声在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。 模型的误差主要来自三部分的总和。 过拟合/欠拟合 欠拟合主要描述的是模型复杂度过低，难以拟合训练数据，此时偏差过大（上图左侧部分） 过拟合是指模型过于复杂，虽然在训练数据上能够较好拟合，但是在测试数据上误差极大，此时偏差较小而误差较大（上图右侧部分） 需要注意的是，测试误差较大不能说明是过拟合还是欠拟合；需要看训练误差的大小以区分。 分类混淆矩阵与风险矩阵混淆矩阵一张图说明混淆矩阵： 混淆矩阵用于预测与实际的差距，对一个N元分类器而言是一个N*N的矩阵，$M[i][j]$表示了预测类为$i$，真实类为$j$的样本数。显然，正确的分类落在矩阵的主对角线上，即所有的$M[i][i]$元素。而其他项表示了分类错误的个数。 当然也有 对于二分类而言，我们会把某一个类叫做正类，另一个类叫做负类，预计某个类为正类叫做阳性，反之叫阴性，所以又产生了如下概念： 预测和真实均为正类的叫做真阳性（TP，True Positive） 预测与真实均为负类的叫做真阴性（TF，True Negative） 预测为正类而真实为负类的叫做假阳性（FP，False Positive） 预测为负类而真实为正类的叫做假阴性（FN，False Negative） 稍加拓展，当应用在多分类上，就是把分类错误统称为负类，分类正确的当做正类。 由此出发，我们得到新的概念作为评价指标： 准确率（Accuracy）：$Accuracy=\\frac{TP+TN}{TP+TN+FP+FN}$ 精确率（Precision）：$Precision=\\frac{TP}{TP+FP}$ 召回率（Recall）：$Recall=\\frac{TP}{TP+FN}$ 这些概念容易搞混，另外与搜索引擎的评估也有一定关联。 那么这三个分类标准分别有什么特点和适用场景？ 我们以检测疾病的分类器为例说明： Accuracy与分类目标无关，实际只看分对了没有；在类别不均衡的问题上评估粒度太大，不如后两种手段有效。因此，在没有特定要求某个类的准确率而是关注整体准确率的时候，使用这一指标。 Precision是指分类器所挑出的某个类中，真正是我们希望的那一类的概率。使用这个为指标就是期待分类器降低把没病的人当作有病的概率。 Recall是指没有被识别出是我们想要的那一类的概率。简单来说就是使用这个指标就是期待分类器不要错放过有病的人。 风险矩阵生活经验中，同样是分类错误，我们对于不同错误分类的容忍度往往是不同的，比如： 垃圾邮件分类问题中，相比重要邮件被错误分类为垃圾邮件而进入垃圾箱，我们更情愿多收到一些被当作正常邮件的垃圾邮件。 在这里如果正类是垃圾邮件，那么我们关注Precision多于Recall；反过来如果正常邮件是正类，那么我们更加关注Recall。 当判决某个细胞是正常细胞还是癌细胞的时候，显然把一个正常细胞错判为癌细胞的风险要比把一个癌细胞错判为正常细胞的风险大很多，后者的错误是致命的。 如果我们的正类是癌细胞，那么我们关注Recall多于Precision，因为我们不希望放过每一个正类。 在这些情形下，同样都是分类错误，某一种分类错误的影响更严重，所以并不是最小错误率（Minimum Probability Error）而是最小风险误差（Minimum Risk）才能够表示我们的期待，这个时候我们会把分类错误添加一个权重，使用权重来改变评判标准。 风险（Risk），可以理解为对某种错误分类情形下造成后果的严重程度，形状和混淆矩阵一致，是人为添加的半定量矩阵。 我们将风险矩阵与混淆矩阵对应位置元素相乘得到的总和就是新的目标函数值，我们的分类结果应当使得这一目标函数值达到最小。 这一改变将如何影响我们的分类策略？ 对一个样本$X_i$： 对每一个类j，我们计算出$X_i$属于j类的概率分别为$P(w_j|X_i)$，并计算j类的误分类风险之和：$\\Sigma_{i!=j}M[j][i]$ 将类的误分类风险与概率相乘，乘积就是j类误分类的概率风险 将每一个类的误分类概率风险求出，找到概率风险最小的那一个分类作为当前的分类 按照这一方法分类计算得到的误分类概率风险是最小的。 从二分类到多分类常见的分类器如支持向量机、感知机只能做到二分类，那么多分类问题应该如何解决？ 主要有以下两种思路： Ont-versus-One：一对一对每一组不同的类$j_1,j_2$，我们构造一个二分类器； 然后，对每一个样本，计算所有分类器，对每一个类进行投票。 One-versus-Rest：一对其余对每一个类$j$，构造一个二分类器，区分的类是第j类和所有的其他类； 然后，对每一个样本，计算所有分类器，此时如果只有一个分类器预测为正类，那么就将其分类为正类；否则，在预测正类的类中挑选置信度最大分类器对应的类。 二者的比较OvO只需要两个类的样本，但是每个分类器需要训练$k(k-1)/2$个分类器； OvR需要k个分类器，但是每个分类器需要训练全部样本。 综合来看，OvO训练的时间开销较小，OvR的存储开销较小。 Multi-versus-Multi：多对多每次选取特定的多个类作为正类，特定的多个类作为负类进行分类，从而确定所属的类区间。 这里选取的类不能随意选取，主要有纠错输出码技术（Error-Correcting Output Codes，ECOC），在此不做展开 ，有兴趣可以参考：https://hyper.ai/wiki/4350 这个推广对其它二分类分类器也适用。 类别不平衡问题类别不平衡（class imbalance），又称为数据偏斜（class skew）。 以二分类问题为例，该问题一般指的是训练集中正负样本数比例相差过大，一般会造成： 类别少的误判惩罚过低，导致有所偏袒，当样本不确定时倾向于把样本分类为多数类。 样本数量分布很不平衡时，特征的分布同样会不平衡。 传统的评价指标变得不可靠，例如准确率。 而在多分类问题中，尽管原始训练集中可能不同类别训练样本数目相当，通过OvR、MvM进行拆分时也有可能会造成上述情况，所以类别不平衡问题亟待解决。 常见的解决方案有： 对较多的那个类别进行欠采样(under-sampling)，舍弃一部分数据，使其与较少类别的数据相当。 对较少的类别进行过采样(over-sampling)，重复使用一部分数据，使其与较多类别的数据相当。 阈值调整（threshold moving），将原本默认为0.5的阈值调整到 较少类别/（较少类别+较多类别）即可。 训练交叉验证交叉验证（Cross Validation）是一种避免过拟合的训练技巧。 具体思路在于将训练切分，每一次用不同的数据集来训练，优化平均的误差，从而降低不同数据集带来模型性能的变化，达到降低方差的目的。 主要有两种方法： K折验证（K-Fold）：指将数据切分为K份，每一份轮流作为验证集（Validation Set），其他数据作为训练数据，训练K轮次获得训练误差。 留一验证（Leave-One-Out）：是K=n的K折验证，通过每次取一个样本作为验证集进行交叉验证训练。 梯度下降梯度下降（Gradient Descent）是在通常模型中通用的迭代型参数估计方法。 我们可以认为，目标函数是一个自变量为模型参数的函数，而我们希望达到它的最大/最小值。 我们知道，一个函数在最大或者最小值的位置，它的一阶梯度为全0的向量。至于它究竟是最大值还是最小值，得看其二阶导数，或者进行测试局部变化来验证。 当然，通常我们会希望目标函数是纯凸/纯凹的，因为这样它的驻点（极大极小值点）只有一个，一旦找到极值点就能够确定它是最优的。在这一理论的驱动下，诞生了凸优化这一学科，目标就是把各种非凸问题转化成凸的问题。 因此我们会对它进行求导，寻找一阶导数为0的点对应的自变量，也就是模型参数的值。 此时，我们可以直接利用等式的梯度为0求解出参数，也可以采用迭代求解的梯度下降方法。 前者看起来不是更直接而且精确嘛？但是事实上我们大多采用的是后者。理由就是，第一个方法的实质是计算方程组的解，涉及求逆矩阵的过程，但是一来计算量大，二来难以保证矩阵非奇异或者非病态的情况下，计算过程对方程组值的扰动非常敏感，噪声带来的误差较大导致结果偏离理论解。 那么，后者是如何操作的？ 在每次训练时，减去梯度值和学习率的乘积。对于一个局部凸的部分，我们可以看到在减去梯度之后我们的参数坐标会向极值点（最低点）靠近，且梯度绝对值越大，下降越快。 理论依据：梯度的反方向就是函数局部值下降最快的方向。 为了快速收敛、避免震荡的目的，也出现了很多学习率优化算法，如自适应性优化（Adam）、Adagrad和随机梯度下降（SGD）、Momentum等策略，这一块暂时不做介绍。 批量梯度下降/随机梯度下降这是梯度下降的两种操作方式。 随机梯度下降（Stochastic Gradient Descent）是指，对每一个训练的样本都计算一次梯度并且用梯度执行更新参数的操作。这种方法的好处是更新次数快，且存在一定的随机性不会陷入局部极小值；但是也因为随机性强，往往梯度的波动大，某一两个样本带来的参数变化太大，更新不稳定，甚至导致不收敛 。 批量梯度下降（Batch Gradient Descent）是指，每次对所有训练样本进行计算梯度并且只用所有梯度的平均值进行一次更新。这种方法的好处自然就是稳定更新；但是其更新太慢，在一定的时间里难以达到收敛，而且也容易陷入局部最小值，最终在较小的梯度下停止更新。 一般来说现有的技巧在于折衷两种方案，进行小批量的梯度下降，并且打乱样本以获取随机性。 这样做的好处在于： 利用了随机梯度下降的随机性，一般不会陷入局部极小值。 更新速度适中，保持较好的稳定性不会震荡，同时也能够较快达到收敛。 最重要的是，方便底层GPU优化。因为梯度计算的底层操作是矩阵运算，而GPU由于多核计算能够并行地计算某一行的计算结果，从而加速梯度更新过程。所以一般而言，小批量梯度下降的效率比随机梯度下降更高。","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"Restart","slug":"Restart","date":"2019-05-28T01:52:55.000Z","updated":"2019-06-02T14:33:47.956Z","comments":true,"path":"Restart/","link":"","permalink":"http://riroaki.github.io/Restart/","excerpt":"","text":"今天把博客文章全都清空了。 主要是之前的文章太乱，缺乏整理；加上近期学了很多东西之后，回头看过去的内容觉得有些浅薄，决心从头开始写。 今后会在这里写一些机器学习，以及数据处理的东西。 当然还有一些工程向的内容，总之我会更加深思熟虑地推送文章。 （是不是也考虑一下换主题呢……哈哈还是算了估计又要挑很久）","categories":[],"tags":[{"name":"Hello, world!","slug":"Hello-world","permalink":"http://riroaki.github.io/tags/Hello-world/"}]}]}