{"meta":{"title":"Riroaki","subtitle":"Riroaki's home","description":"我还要去完成应做之事。","author":"Riroaki","url":"http://riroaki.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-24T12:33:57.000Z","updated":"2019-04-09T12:06:40.449Z","comments":true,"path":"about/index.html","permalink":"http://riroaki.github.io/about/index.html","excerpt":"","text":"这里是Riroaki的个人小站。 用来标记自己来时的路。"},{"title":"categories","date":"2019-03-24T12:31:34.000Z","updated":"2019-04-09T12:04:49.546Z","comments":true,"path":"categories/index.html","permalink":"http://riroaki.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-24T12:26:06.000Z","updated":"2019-04-09T12:05:24.696Z","comments":true,"path":"tags/index.html","permalink":"http://riroaki.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机器学不动了-2：贝叶斯分类","slug":"Machine-Learning-01-Bayes","date":"2019-06-21T04:00:00.000Z","updated":"2019-06-21T17:54:57.729Z","comments":true,"path":"Machine-Learning-01-Bayes/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-01-Bayes/","excerpt":"","text":"本文是”机器学不动了”系列的第二篇内容，可以结合个人实现的代码食用： https://github.com/Riroaki/LemonML/ 引子贝叶斯分类的核心是贝叶斯公式： $P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$ $P(A) = \\Sigma_{i=1}^n{P(B|A_i)P(A_i)}$ 贝叶斯公式对多元变量同样适用，与变量是否独立也无关，是普适的公式。 为了介绍这个公式，我们首先来看一道概率题： 现分别有 A、B 两个容器，在容器 A 里分别有 7 个红球和 3 个白球，在容器 B 里有 1 个红球和 9 个白球，而设定从A中抽取的概率和B中抽取的概率为1:2。 现已知从这两个容器里任意抽出了一个红球，问这个球来自容器 A 的概率是多少? 记抽中红球的事件为$P(B)$，记从容器A抽球的概率为$P(A)$。 根据贝叶斯公式，我们有：$P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$。其中$P(B|A)$表示从容器A中抽球，抽到红球的概率。 在这个公式中： $P(A|B)$是已知B发生后A的条件概率，也叫做A的后验概率（posterior probability）。 $P(B|A)$是已知A发生后B的条件概率，是B的后验概率，在这里叫A的似然概率（likelihood）。 $P(A)$是事件发生之前我们对A的经验知识，与B无关，叫做A的先验概率（prior probability）。 $P(B)$是B的先验概率，在这里叫做标准化常量（normalized constant）。 根据这个关系，后验$P(A|B)$也可以叫做标准化的似然；似然和后验是可以相互转化的。 贝叶斯分类理论从这个公式引申开，我们可以套用在分类理论上： 我们可以类比认为每一个类对应一个容器，样本都是这个类中生成（取出）的。 分类问题可以采用这样的表述：已知一个待归类样本$X_i$的特征，那么求$X_i$属于第j个类的概率，就变成了一个后验概率。 把样本属于第j个类的概率记作事件$w_j$，这个后验概率可以表述为：$P(w_j|x=X_i)$，简记作$P(w_j|X_i)$。 那么，根据贝叶斯公式，我们有：$P(w_j|X_i)=\\frac{P(X_i|w_j)P(w_j)}{P(X_i)}$。 这里的似然是$P(X_i|w_j)$，先验概率是$P(w_j)$，标准化常量为$P(X_i)$。 那么，有了某个样本属于各个类别的概率，如何分类呢？ 很自然的，我们选择后验概率比较大的那一个概率对应的类别作为$X_i$的分类。 补充1：当我们只有先验概率的时候，我们选择先验概率较大的那一个类别作为分类。 补充2：当采用混淆矩阵（confusion matrix）进行评估的时候，分类规则会更复杂一些，将在下文中作为拓展内容介绍。 参数估计我们已经有了概率的公式和决策理论，如何估计概率公式中的各个概率？ 答案是：从有类标签的数据（训练数据）中总结提取。 先验概率的估计这里的先验概率，就是在没有训练样本具体特征的值的分布情况下，某个类原始的信息。 很自然的，我们会把这个类别的样本数占全部有标签的样本的比重当作先验概率， 即：$P(w_j)=\\Sigma_{i=1}^N{I(y_i=c_j)}/N$ 似然概率的估计我们有不同的假设可以做出不同的估计。常用的有高斯分布假设、二项分布假设、伯努利分布。 这里只介绍高斯分布假设对应的参数估计方法。 高斯分布的具体假设：对于某一个类$c_i$，其生成的样本满足高斯分布，即：$X\\sim N(\\mu, \\Sigma)$ 在这里我们采用极大似然估计（Maximum Likelihood Estimation）的做法来选取最佳参数： 目标函数是$L(\\mu_j,\\Sigma_j)=\\prod_{i=1}^N{P(X_i|w_j)}$。 由于不方便对目标函数求导，我们采用取对数的技巧，将连乘转化为连加：$l(\\mu_j,\\Sigma_j)=log(L)=\\Sigma_{i=1}^NP(X_i|w_j)$ 对对数似然求导，令导数为0求出$\\mu,\\Sigma$的过程比较复杂，详情参考附录。 总之，最终求出的结果和标量形式的惊人一致： $\\hat\\mu_j=\\frac{1}{N_j}\\Sigma_{i=0}^{N_j}X_i=\\bar{x}$ $\\hat\\Sigma=\\frac{1}{N_j}\\Sigma_{i=1}^{N_j}(X_i-\\hat\\mu)(X_i-\\hat\\mu)^T=cov(X_i), where\\ y_i = w_j$ 很容易联想到标量情况下，$\\hat\\mu=\\bar{X}, \\hat\\sigma=var(X)$ 有了估计的参数以后，我们可以通过高斯概率密度公式求似然概率：$P(X; \\mu, \\Sigma)=\\frac{1}{(2\\pi)^{d/2}|\\Sigma|^{1/2}}exp(-\\frac{1}{2}(X-\\mu)^T\\Sigma^{-1}(X-\\mu))$ 标准化常量这一项，理论上可以通过$P(X_i)=\\Sigma_{j=1}^cP(X_i|w_j)P(w_j)$求出，也就是说得算出对样本对每一个类的先验概率和似然的乘积之和，才能计算分母。 然而正常情况下，它并不在我们的考虑范围内： 因为，每一个类的计算概率的分母都是这一项。既然我们最终的目标是比较后验概率的大小（或者与混淆矩阵关联后的大小，whatever），这一项作为相同的系数并不会产生影响：） 目标函数在这里因为我们并不是采取迭代优化，而是通过假设模型直接估计得出参数，所以不需要目标函数可导。 采用0-1损失函数就可以，即分类错误，结果就加一，分类正确结果就不变化的函数。 当然存在更复杂的形式，这就是在加入混淆矩阵之后需要考虑的事情： 混淆矩阵生活经验中，同样是分类错误，我们对于不同错误分类的容忍度往往是不同的，比如： 垃圾邮件分类问题中，相比重要邮件被错误分类为垃圾邮件而进入垃圾箱，我们更情愿多收到一些被当作正常邮件的垃圾邮件。 …… 待续。 附录：多维高斯参数估计推导（Deriving the Maximum Likelihood Estimators）来源：https://stats.stackexchange.com/questions/351549/maximum-likelihood-estimators-multivariate-gaussian 或者查看文档版本：https://people.eecs.berkeley.edu/~jordan/courses/260-spring10/other-readings/chapter13.pdf","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"机器学不动了-1：机器学习基础","slug":"Machine-Learning-00-Basics","date":"2019-06-20T16:00:00.000Z","updated":"2019-06-21T17:54:59.278Z","comments":true,"path":"Machine-Learning-00-Basics/","link":"","permalink":"http://riroaki.github.io/Machine-Learning-00-Basics/","excerpt":"","text":"本文是”机器学不动了”系列的第一篇内容，可以结合个人实现的代码食用： https://github.com/Riroaki/LemonML/ 引子如今深度学习、数据挖掘、机器学习这些概念已经🔥到成为满大街都是的概念，由于其门槛低（调包）和某些fancy的功能，加上媒体的宣传和高薪的诱惑，无论计算机专业还是非计算机专业出身的人们都热衷于在其中寻找机会，我这个软工的菜🐔也不例外。当然，目前正处于新手期。 这一个系列主要记录了我学习和梳理的机器学习的知识，包含数学理论和代码实现，希望能够给入门者（包括我自己）提供一个参考。 由于本人懒癌晚期，博客将不定期更新。 看客们如果有问题或者留言可以直接在相关的博文下面留言，我们可以共同探讨解决。 当然也可以邮件联系本人：lilq@1285.com，欢迎理性讨论。 本系列内容属于个人原创，转载请声明出处，商业转载请联系本人，邮箱同上。 机器学习总览机器学习发源于统计学，主要的目标是用数学和程序语言描述事物的规律，从而为预测、决策提供参考。 以全局的视角来看机器学习这一领域的算法，主要分为有监督（Supervised）学习和无监督（Unsupervised）学习两类，此外还有半监督（Half-supervised）学习、强化（Reinforcement）学习： 有监督学习主要任务 回归（Regression）通常目标是得到连续的曲线，输出是连续的值 分类（Classification）通常目标是得到决策的边界，输出的是离散的类别 常见算法 Linear Regression：线性回归，以线性方式组合特征拟合连续曲线 Bayes：贝叶斯分类，通过概率模型计算样本属于各个分类的后验概率，进行分类 Logistic Regression：逻辑回归，在线性回归基础上增加激活函数以进行分类 Support Vector Machine：支持向量机，选取决策面较近的点用来计算决策面的参数 K Nearest Neighbor：K近邻，寻找距离较近的K个样本的标签取众数作为样本归类 Perceptron：感知机，二分类算法，最简单的神经网络 Decision Tree：决策树，可以看作从样本数据中学习if-else语句的组合，每一个判断都是数的一个节点，实现分类 Linear Discriminant Analysis：线性判别分析，通过找到特征的线性组合以用于降维，也是一种分类算法 算法的分类 如果从算法解决的问题分类，可以分为回归和分类两大类算法： 其中，线性回归为回归类的算法，其余算法均主要用于分类，当然也可以有回归的作用。因为这些分类算法大多是在连续的输出外进行处理获得类别，如逻辑回归、感知机、支持向量机等，如果用在回归上则输出的是分类前计算的结果。 如果从决策面的角度来看，上述的分类算法可以分为线性分类算法和非线性分类算法： 线性分类算法：分类面为线性/输出函数为线性形式（本质相同，采用不同的目标函数得到的模型） 包括：逻辑回归、支持向量机、感知机、线性判别分析 非线性算法：分类面为非线性/输出函数的形式为非线性 包括：贝叶斯、K近邻、决策树 如果从算法的实际含义角度看，上述的分类算法可以分为生成模型和判别模型： 生成模型：按照条件概率建立模型，基于高斯分布等假设，学习模型的参数用于分类 包括：贝叶斯模型、线性判别分析 判别模型：出于最大化在测试集上的表现，进行训练 包括：大部分其他分类算法 在基本算法的基础上，现代机器学习常见的还有集成（Ensemble）学习，其核心是”三个臭屁匠，顶个诸葛亮”，并不致力于产生最强的单个分类器，而是通过把训练不同的较弱分类器，并进行集合决策以获得最好的分类效果。 集成学习 Bagging/Bootstrap Aggregating：通过随机切分数据集，并行训练相同模型以获得更好的分类效果。 随机森林（Random Forest）算法正是基于bagging算法实现。 Boosting：通过训练一系列弱分类器并组合获得强分类器。 Stacking：训练一个组合不同模型的高层模型进行分类（上面两种算法对底层模型的组合方式是确定的）。 无监督学习主要任务 降维（Dimensionality Reduction）指的是将样本空间从高维特征投影到较低维度的特征从而实现提高计算效率的作用。 聚类（Clustering）指的是将无标签的样本按照样本之间的距离信息等，将相近的样本归为一个簇的算法，可以理解为没有样本标签的分类算法。 常见算法 Principle Component Analysis：主成分分析，通过提取协方差矩阵中的特征向量作为新特征实现降维。 与线性判别分析（LDA）相似的算法。 K Means：K均值算法，通过抽取相近点簇的重心作为簇的代表来实现聚类。 K Medoids：K中心点算法，和K Means算法相近，不同的是选取簇中最接近重心的点作为簇的代表。 Spectral Clustering：谱聚类，通过降维方法和K Means算法实现聚类。 Gaussian Mixture Model：高斯混合模型，是基于高斯分布的假设，通过点簇的分布估计参数以实现聚类。 K Means算法可以视为GMM的一种特殊形式。 Matrix Factorization：矩阵分解，是一类降维算法，包括奇异值分解、矩阵非负分解和稀疏编码等算法。 算法的分类 如果按照主要任务，可以将算法分为降维算法和聚类算法： 降维算法：主要包括主成分分析、矩阵分解 聚类算法：主要包括K均值、K中心点、谱聚类、高斯混合模型 半监督学习利用少量标注样本和大量未标注样本进行机器学习的算法。 由于本人并不了解这一块，所以此处内容不作详细介绍，有兴趣者请自行谷歌。 强化学习没有特定的目标，强调环境的反馈作用，通过应对环境调整策略的算法。 由于本人并不了解这一块，所以此处内容不作详细介绍，有兴趣者请自行谷歌。 深度学习这一块是近十年新的方向，也是目前机器学习最火的分支，但是预计不会在近期内容中出现。 简言之，深度学习就是基于神经网络的算法，通过组合线性的神经元和非线性的激活层，以及搭建不同结构的网络，来实现回归或者预测、聚类等工作。 其”神经网络”形态的灵感得益于生物大脑的神经元连接结构，让人联想到”机器的大脑🧠”，加上诸如alphaGo等等一些新奇的成就带来的狂热使得众人为之疯狂，许多营销号和媒体甚至脑洞大开，大肆鼓吹”人工智能有害论”。 但目前而言，可解释性差、缺乏较统一的数学理论描述是其硬伤。而且也没有出现强人工智能的迹象，目前的神经网络，本质只是一种复杂的统计模型。 随着研究陷入瓶颈，这场资本与舆论的狂欢已经在逐渐冷却，未来究竟如何发展也未可知：） 机器学习方法论机器学习的本质在于从数据或者假设中建立模型、学习参数，去拟合一个未知的函数。 根据论文《A Few Useful Things to Know about Machine Learning》，机器学习的过程可以表示为： $LEARNING = REPRESENTATION + EVALUATION + OPTIMIZATION$ 也就是说，机器学习主要分为三个过程： 表示（Representation）：使用计算机能够执行的语言描述算法。这个阶段确定了模型的类型，所以决定了拟合/分类函数的假设空间（Hypothesis Space）——也就是说，在这一步，模型的参数个数和模型的计算方式已经确定，比如线性模型的$y=WX+B$，那么模型无法模拟非线性的分类/回归，这是选取的模型导致的。而具体是如何线性的函数，需要在接下来的过程中确定。 评估（Evaluation）：用于评估模型的好坏。根据任务的不同（回归、分类）确定了不同的种类，同时这个评估方法应当是能够方便地找到对应的优化函数的（更明确一点，评估的函数应该是可导的）。我们训练的目标就是最小化目标函数（误差型）或者最大化目标函数（精度型）。 优化（Optimization）：评估函数就像考试，有了考试我们就可以知道自己的薄弱环节，从而确定努力的方向。而有了评估函数，就有一个对应的优化函数用于调整模型的参数。 通常我们采用基于梯度的方法，具体会在下面梯度下降这一概念中解释。 论文中列出了一个关于这三个部分的表格，在这里贴出来： 从表格也可以看出来，对某一种算法，并非所有的评估函数都能够使用，有些算法是绑定了评估函数的。 同时，评估函数与优化函数存在对应关系，选择某一类评估函数时，对应的优化策略也就决定了。 基本概念梯度下降梯度下降（Gradient Descent）是在通常模型中通用的迭代型参数估计方法。 我们可以认为，目标函数是一个自变量为模型参数的函数，而我们希望达到它的最大/最小值。 我们知道，一个函数在最大或者最小值的位置，它的一阶梯度为全0的向量。至于它究竟是最大值还是最小值，得看其二阶导数，或者进行测试局部变化来验证。 当然，通常我们会希望目标函数是纯凸/纯凹的，因为这样它的驻点（极大极小值点）只有一个，一旦找到极值点就能够确定它是最优的。在这一理论的驱动下，诞生了凸优化这一学科，目标就是把各种非凸问题转化成凸的问题。 因此我们会对它进行求导，寻找一阶导数为0的点对应的自变量，也就是模型参数的值。 此时，我们可以直接利用等式的梯度为0求解出参数，也可以采用迭代求解的梯度下降方法。 前者看起来不是更直接嘛？但是事实上我们大多采用的是后者。理由就是，第一个方法的实质是计算方程组的解，涉及求逆矩阵的过程，但是一来计算量大，二来难以保证矩阵非奇异或者非病态的情况下，计算过程对方程组值的扰动非常敏感，噪声带来的误差较大导致结果偏离理论解。 那么，后者是如何操作的？ 在每次训练时，减去梯度值和学习率的乘积。对于一个局部凸的部分，我们可以看到在减去梯度之后我们的参数坐标会向极值点（最低点）靠近，且梯度绝对值越大，下降越快。 理论依据：梯度的反方向就是函数局部值下降最快的方向。 为了快速收敛、避免震荡的目的，也出现了很多学习率优化算法，如自适应性优化（Adam）、Adagrad和随机梯度下降（SGD）、Momentum等策略，这一块暂时不做介绍。 泛化 、方差、偏差和噪声首先，泛化（Generalization）是指模型在经过一定的数据训练之后对现实数据进行测试，我们希望模型能够最小化测试误差（testing error），而训练数据集上的误差与测试数据集上的误差就是泛化误差（Generalization Error）。 而泛化误差分为方差（Variance）与偏差（Bias），通过这两个方面可以描述模型与现实模型的误差： Bias是模型预测与真实结果的差距，可以直观理解为训练误差（training error），表现了模型的拟合能力； Variance则是“（大小相同的）不同训练数据集训练出的模型”的训练误差之间的差异，表现了数据扰动的影响。 通常来说，模型越复杂（组成模型的参数越多），方差越大，偏差越小，这是因为模型的描述能力越强；模型越简单，偏差也容易大，很可能无法拟合训练数据。 通常模型复杂程度与方差/偏差的关系： 在图中可以看到，随着模型变得复杂，训练误差/偏差变小，而方差（在图中可以看作测试误差与训练误差之间的差值）变大，训练误差在中间有一个较低值。 由此启发我们寻找一个复杂度的平衡点，使得模型具有较低的bias和variance；至于noise则是无法改变的。 此外，还有一个概念叫做噪声（noise）：噪声在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。 模型的误差主要来自三部分的总和。 过拟合/欠拟合 欠拟合主要描述的是模型复杂度过低，难以拟合训练数据，此时偏差过大（上图左侧部分） 过拟合是指模型过于复杂，虽然在训练数据上能够较好拟合，但是在测试数据上误差极大，此时偏差较小而误差较大（上图右侧部分） 需要注意的是，测试误差较大不能说明是过拟合还是欠拟合；需要看训练误差的大小以区分。 训练技巧交叉验证交叉验证（Cross Validation）是一种避免过拟合的训练技巧。 具体思路在于将训练切分，每一次用不同的数据集来训练，优化平均的误差，从而降低不同数据集带来模型性能的变化，达到降低方差的目的。 主要有两种方法： K折验证（K-Fold）：指将数据切分为K份，每一份轮流作为验证集（Validation Set），其他数据作为训练数据，训练K轮次获得训练误差。 留一验证（Leave-One-Out）：是K=n的K折验证，通过每次取一个样本作为验证集进行交叉验证训练。 批量梯度下降/随机梯度下降这是梯度下降的两种操作方式。 随机梯度下降（Stochastic Gradient Descent）是指，对每一个训练的样本都计算一次梯度并且用梯度执行更新参数的操作。这种方法的好处是更新次数快，且存在一定的随机性不会陷入局部极小值；但是也因为随机性强，往往梯度的波动大，某一两个样本带来的参数变化太大，更新不稳定，甚至导致不收敛 。 批量梯度下降（Batch Gradient Descent）是指，每次对所有训练样本进行计算梯度并且只用所有梯度的平均值进行一次更新。这种方法的好处自然就是稳定更新；但是其更新太慢，在一定的时间里难以达到收敛，而且也容易陷入局部最小值，最终在较小的梯度下停止更新。 一般来说现有的技巧在于折衷两种方案，进行小批量的梯度下降，并且打乱样本以获取随机性。 这样做的好处在于： 利用了随机梯度下降的随机性，一般不会陷入局部极小值。 更新速度适中，保持较好的稳定性不会震荡，同时也能够较快达到收敛。 最重要的是，方便底层GPU优化。因为梯度计算的底层操作是矩阵运算，而GPU由于多核计算能够并行地计算某一行的计算结果，从而加速梯度更新过程。所以一般而言，小批量梯度下降的效率比随机梯度下降更高。 本篇完。后续内容将大致按照本篇的顺序，依次介绍主要的几种具体算法以及其他技巧等内容。","categories":[{"name":"机器学不动了","slug":"机器学不动了","permalink":"http://riroaki.github.io/categories/机器学不动了/"}],"tags":[{"name":"Data Mining","slug":"Data-Mining","permalink":"http://riroaki.github.io/tags/Data-Mining/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://riroaki.github.io/tags/Machine-Learning/"}]},{"title":"Restart","slug":"Restart","date":"2019-05-28T01:52:55.000Z","updated":"2019-06-02T14:33:47.956Z","comments":true,"path":"Restart/","link":"","permalink":"http://riroaki.github.io/Restart/","excerpt":"","text":"今天把博客文章全都清空了。 主要是之前的文章太乱，缺乏整理；加上近期学了很多东西之后，回头看过去的内容觉得有些浅薄，决心从头开始写。 今后会在这里写一些机器学习，以及数据处理的东西。 当然还有一些工程向的内容，总之我会更加深思熟虑地推送文章。 （是不是也考虑一下换主题呢……哈哈还是算了估计又要挑很久）","categories":[],"tags":[{"name":"Hello, world!","slug":"Hello-world","permalink":"http://riroaki.github.io/tags/Hello-world/"}]}]}